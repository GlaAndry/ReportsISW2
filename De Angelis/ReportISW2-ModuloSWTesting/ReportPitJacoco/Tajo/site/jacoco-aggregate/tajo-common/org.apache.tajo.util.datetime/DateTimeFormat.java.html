<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeFormat.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Apache Tajo :: Tests Coverage</a> &gt; <a href="../index.html" class="el_bundle">tajo-common</a> &gt; <a href="index.source.html" class="el_package">org.apache.tajo.util.datetime</a> &gt; <span class="el_source">DateTimeFormat.java</span></div><h1>DateTimeFormat.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.tajo.util.datetime;

import org.apache.tajo.datum.TimestampDatum;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * This class originated from src/backend/utils/adt/formatting.c of PostgreSQL
 */
<span class="nc" id="L31">public class DateTimeFormat {</span>
  /* ----------
   * Full months_short
   * ----------
   */
<span class="fc" id="L36">  static final String[] months_full = {</span>
    &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
        &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;, null
  };

<span class="fc" id="L41">  static String[] days_short = {</span>
    &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, null
  };

<span class="fc" id="L45">  static String[] months_short = {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,</span>
      &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;, null};

<span class="fc" id="L48">  static String[] days_full = {&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,</span>
      &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, null};

<span class="fc" id="L51">  static int[][] ysum = {</span>
    {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
    {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}
  };


  /**
   *  AD / BC
   * ----------
   * There is no 0 AD.  Years go from 1 BC to 1 AD, so we make it
   * positive and map year == -1 to year zero, and shift all negative
   * years up one.  For interval years, we just return the year.
   * @param year
   * @param is_interval
   * @return
   */
  static int ADJUST_YEAR(int year, boolean is_interval)	{
<span class="nc bnc" id="L68" title="All 4 branches missed.">    return ((is_interval) ? (year) : ((year) &lt;= 0 ? -((year) - 1) : (year)));</span>
  }

  static final String A_D_STR	= &quot;A.D.&quot;;
  static final String a_d_STR	= &quot;a.d.&quot;;
  static final String AD_STR = &quot;AD&quot;;
  static final String ad_STR = &quot;ad&quot;;

  static final String B_C_STR	= &quot;B.C.&quot;;
  static final String b_c_STR	= &quot;b.c.&quot;;
  static final String BC_STR = &quot;BC&quot;;
  static final String bc_STR = &quot;bc&quot;;

  /**
   * AD / BC strings for seq_search.
   *
   * These are given in two variants, a long form with periods and a standard
   * form without.
   *
   * The array is laid out such that matches for AD have an even index, and
   * matches for BC have an odd index.  So the boolean value for BC is given by
   * taking the array index of the match, modulo 2.
   */
<span class="fc" id="L91">  static final String[] adbc_strings = {ad_STR, bc_STR, AD_STR, BC_STR, null};</span>
<span class="fc" id="L92">  static final String[] adbc_strings_long = {a_d_STR, b_c_STR, A_D_STR, B_C_STR, null};</span>

  /**
   * ----------
   * AM / PM
   * ----------
   */
  static final String A_M_STR	= &quot;A.M.&quot;;
  static final String a_m_STR	= &quot;a.m.&quot;;
  static final String AM_STR = &quot;AM&quot;;
  static final String am_STR = &quot;am&quot;;

  static final String P_M_STR	= &quot;P.M.&quot;;
  static final String p_m_STR	= &quot;p.m.&quot;;
  static final String PM_STR = &quot;PM&quot;;
  static final String pm_STR = &quot;pm&quot;;

  /**
   * AM / PM strings for seq_search.
   *
   * These are given in two variants, a long form with periods and a standard
   * form without.
   *
   * The array is laid out such that matches for AM have an even index, and
   * matches for PM have an odd index.  So the boolean value for PM is given by
   * taking the array index of the match, modulo 2.
   */
<span class="fc" id="L119">  static final String[] ampm_strings = {am_STR, pm_STR, AM_STR, PM_STR, null};</span>
<span class="fc" id="L120">  static final String[] ampm_strings_long = {a_m_STR, p_m_STR, A_M_STR, P_M_STR, null};</span>

  /**
   * ----------
   * Months in roman-numeral
   * (Must be in reverse order for seq_search (in FROM_CHAR), because
   *	'VIII' must have higher precedence than 'V')
   * ----------
   */
<span class="fc" id="L129">  static final String[] rm_months_upper =</span>
    {&quot;XII&quot;, &quot;XI&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;VIII&quot;, &quot;VII&quot;, &quot;VI&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;III&quot;, &quot;II&quot;, &quot;I&quot;, null};

<span class="fc" id="L132">  static final String[] rm_months_lower =</span>
    {&quot;xii&quot;, &quot;xi&quot;, &quot;x&quot;, &quot;ix&quot;, &quot;viii&quot;, &quot;vii&quot;, &quot;vi&quot;, &quot;v&quot;, &quot;iv&quot;, &quot;iii&quot;, &quot;ii&quot;, &quot;i&quot;, null};

  /**
   * ----------
   * Roman numbers
   * ----------
   */
<span class="fc" id="L140">  static final String[] rm1 = {&quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;, null};</span>
<span class="fc" id="L141">  static final String[] rm10 = {&quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;, null};</span>
<span class="fc" id="L142">  static final String[] rm100 = {&quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;, null};</span>

  /**
   * ----------
   * Ordinal postfixes
   * ----------
   */
<span class="fc" id="L149">  static final String[] numTH = {&quot;ST&quot;, &quot;ND&quot;, &quot;RD&quot;, &quot;TH&quot;, null};</span>
<span class="fc" id="L150">  static final String[] numth = {&quot;st&quot;, &quot;nd&quot;, &quot;rd&quot;, &quot;th&quot;, null};</span>

  /**
   * ----------
   * Flags &amp; Options:
   * ----------
   */
  static final int ONE_UPPER = 1;		/* Name */
  static final int ALL_UPPER = 2;		/* NAME */
  static final int ALL_LOWER = 3;		/* name */

  static final int MAX_MONTH_LEN = 9;
  static final int MAX_MON_LEN = 3;
  static final int MAX_DAY_LEN = 9;
  static final int MAX_DY_LEN	= 3;
  static final int MAX_RM_LEN	= 4;

  static final int DCH_S_FM =	0x01;
  static final int DCH_S_TH	= 0x02;
  static final int DCH_S_th	= 0x04;
  static final int DCH_S_SP	= 0x08;
  static final int DCH_S_TM	= 0x10;

  static final int NODE_TYPE_END = 1;
  static final int NODE_TYPE_ACTION = 2;
  static final int NODE_TYPE_CHAR = 3;

  static final int SUFFTYPE_PREFIX = 1;
  static final int SUFFTYPE_POSTFIX = 2;

  static final int CLOCK_24_HOUR = 0;
  static final int CLOCK_12_HOUR = 1;

  static final int MONTHS_PER_YEAR = 12;
  static final int HOURS_PER_DAY = 24;

  /**
   * ----------
   * Maximal length of one node
   * ----------
   */
  static final int DCH_MAX_ITEM_SIZ	= 9;		/* max julian day		*/
  static final int NUM_MAX_ITEM_SIZ	= 8;		/* roman number (RN has 15 chars)	*/

<span class="fc" id="L194">  enum FORMAT_TYPE {</span>
<span class="fc" id="L195">    DCH_TYPE, NUM_TYPE</span>
  }

  /**
   * ----------
   * Suffixes definition for DATE-TIME TO/FROM CHAR
   * ----------
   */
<span class="fc" id="L203">  static KeySuffix[] DCH_suff = {</span>
    new KeySuffix(&quot;FM&quot;, 2, DCH_S_FM, SUFFTYPE_PREFIX),
    new KeySuffix(&quot;fm&quot;, 2, DCH_S_FM, SUFFTYPE_PREFIX),
    new KeySuffix(&quot;TM&quot;, 2, DCH_S_TM, SUFFTYPE_PREFIX),
    new KeySuffix(&quot;tm&quot;, 2, DCH_S_TM, SUFFTYPE_PREFIX),
    new KeySuffix(&quot;TH&quot;, 2, DCH_S_TH, SUFFTYPE_POSTFIX),
    new KeySuffix(&quot;th&quot;, 2, DCH_S_th, SUFFTYPE_POSTFIX),
    new KeySuffix(&quot;SP&quot;, 2, DCH_S_SP, SUFFTYPE_POSTFIX),
  };

  /**
   * ----------
   * Format-pictures (KeyWord).
   *
   * The KeyWord field; alphabetic sorted, *BUT* strings alike is sorted
   *		  complicated -to-&gt; easy:
   *
   *	(example: &quot;DDD&quot;,&quot;DD&quot;,&quot;Day&quot;,&quot;D&quot; )
   *
   * (this specific sort needs the algorithm for sequential search for strings,
   * which not has exact end; -&gt; How keyword is in &quot;HH12blabla&quot; ? - &quot;HH&quot;
   * or &quot;HH12&quot;? You must first try &quot;HH12&quot;, because &quot;HH&quot; is in string, but
   * it is not good.
   *
   * (!)
   *	 - Position for the keyword is similar as position in the enum DCH/NUM_poz.
   * (!)
   *
   * For fast search is used the 'int index[]', index is ascii table from position
   * 32 (' ') to 126 (~), in this index is DCH_ / NUM_ enums for each ASCII
   * position or -1 if char is not used in the KeyWord. Search example for
   * string &quot;MM&quot;:
   *	1)	see in index to index['M' - 32],
   *	2)	take keywords position (enum DCH_MI) from index
   *	3)	run sequential search in keywords[] from this position
   *
   * ----------
   */
<span class="fc" id="L241">  enum DCH_poz {</span>
<span class="fc" id="L242">    DCH_A_D(0),</span>
<span class="fc" id="L243">    DCH_A_M(1),</span>
<span class="fc" id="L244">    DCH_AD(2),</span>
<span class="fc" id="L245">    DCH_AM(3),</span>
<span class="fc" id="L246">    DCH_B_C(4),</span>
<span class="fc" id="L247">    DCH_BC(5),</span>
<span class="fc" id="L248">    DCH_CC(6),</span>
<span class="fc" id="L249">    DCH_DAY(7),</span>
<span class="fc" id="L250">    DCH_DDD(8),</span>
<span class="fc" id="L251">    DCH_DD(9),</span>

<span class="fc" id="L253">    DCH_DY(10),</span>
<span class="fc" id="L254">    DCH_Day(11),</span>
<span class="fc" id="L255">    DCH_Dy(12),</span>
<span class="fc" id="L256">    DCH_D(13),</span>
<span class="fc" id="L257">    DCH_FX(14),						/* global suffix */</span>
<span class="fc" id="L258">    DCH_HH24(15),</span>
<span class="fc" id="L259">    DCH_HH12(16),</span>
<span class="fc" id="L260">    DCH_HH(17),</span>
<span class="fc" id="L261">    DCH_IDDD(18),</span>
<span class="fc" id="L262">    DCH_ID(19),</span>

<span class="fc" id="L264">    DCH_IW(20),</span>
<span class="fc" id="L265">    DCH_IYYY(21),</span>
<span class="fc" id="L266">    DCH_IYY(22),</span>
<span class="fc" id="L267">    DCH_IY(23),</span>
<span class="fc" id="L268">    DCH_I(24),</span>
<span class="fc" id="L269">    DCH_J(25),</span>
<span class="fc" id="L270">    DCH_MI(26),</span>
<span class="fc" id="L271">    DCH_MM(27),</span>
<span class="fc" id="L272">    DCH_MONTH(28),</span>
<span class="fc" id="L273">    DCH_MON(29),</span>

<span class="fc" id="L275">    DCH_MS(30),</span>
<span class="fc" id="L276">    DCH_Month(31),</span>
<span class="fc" id="L277">    DCH_Mon(32),</span>
<span class="fc" id="L278">    DCH_P_M(33),</span>
<span class="fc" id="L279">    DCH_PM(34),</span>
<span class="fc" id="L280">    DCH_Q(35),</span>
<span class="fc" id="L281">    DCH_RM(36),</span>
<span class="fc" id="L282">    DCH_SSSS(37),</span>
<span class="fc" id="L283">    DCH_SS(38),</span>
<span class="fc" id="L284">    DCH_TZ(39),</span>

<span class="fc" id="L286">    DCH_US(40),</span>
<span class="fc" id="L287">    DCH_WW(41),</span>
<span class="fc" id="L288">    DCH_W(42),</span>
<span class="fc" id="L289">    DCH_Y_YYY(43),</span>
<span class="fc" id="L290">    DCH_YYYY(44),</span>
<span class="fc" id="L291">    DCH_YYY(45),</span>
<span class="fc" id="L292">    DCH_YY(46),</span>
<span class="fc" id="L293">    DCH_Y(47),</span>
<span class="fc" id="L294">    DCH_a_d(48),</span>
<span class="fc" id="L295">    DCH_a_m(49),</span>

<span class="fc" id="L297">    DCH_ad(50),</span>
<span class="fc" id="L298">    DCH_am(51),</span>
<span class="fc" id="L299">    DCH_b_c(52),</span>
<span class="fc" id="L300">    DCH_bc(53),</span>
<span class="fc" id="L301">    DCH_cc(54),</span>
<span class="fc" id="L302">    DCH_day(55),</span>
<span class="fc" id="L303">    DCH_ddd(56),</span>
<span class="fc" id="L304">    DCH_dd(57),</span>
<span class="fc" id="L305">    DCH_dy(58),</span>
<span class="fc" id="L306">    DCH_d(59),</span>

<span class="fc" id="L308">    DCH_fx(60),</span>
<span class="fc" id="L309">    DCH_hh24(61),</span>
<span class="fc" id="L310">    DCH_hh12(62),</span>
<span class="fc" id="L311">    DCH_hh(63),</span>
<span class="fc" id="L312">    DCH_iddd(64),</span>
<span class="fc" id="L313">    DCH_id(65),</span>
<span class="fc" id="L314">    DCH_iw(66),</span>
<span class="fc" id="L315">    DCH_iyyy(67),</span>
<span class="fc" id="L316">    DCH_iyy(68),</span>
<span class="fc" id="L317">    DCH_iy(69),</span>

<span class="fc" id="L319">    DCH_i(70),</span>
<span class="fc" id="L320">    DCH_j(71),</span>
<span class="fc" id="L321">    DCH_mi(72),</span>
<span class="fc" id="L322">    DCH_mm(73),</span>
<span class="fc" id="L323">    DCH_month(74),</span>
<span class="fc" id="L324">    DCH_mon(75),</span>
<span class="fc" id="L325">    DCH_ms(76),</span>
<span class="fc" id="L326">    DCH_p_m(77),</span>
<span class="fc" id="L327">    DCH_pm(78),</span>
<span class="fc" id="L328">    DCH_q(79),</span>

<span class="fc" id="L330">    DCH_rm(80),</span>
<span class="fc" id="L331">    DCH_ssss(89),</span>
<span class="fc" id="L332">    DCH_ss(90),</span>
<span class="fc" id="L333">    DCH_tz(91),</span>
<span class="fc" id="L334">    DCH_us(92),</span>
<span class="fc" id="L335">    DCH_ww(93),</span>
<span class="fc" id="L336">    DCH_w(94),</span>
<span class="fc" id="L337">    DCH_y_yyy(95),</span>
<span class="fc" id="L338">    DCH_yyyy(96),</span>
<span class="fc" id="L339">    DCH_yyy(97),</span>
<span class="fc" id="L340">    DCH_yy(98),</span>
<span class="fc" id="L341">    DCH_y(99),</span>
<span class="fc" id="L342">    _DCH_last_(Integer.MAX_VALUE);</span>

    int value;
<span class="fc" id="L345">    DCH_poz(int value) {</span>
<span class="fc" id="L346">      this.value = value;</span>
<span class="fc" id="L347">    }</span>

    public int getValue() {
<span class="nc" id="L350">      return value;</span>
    }
  }

  /**
   * ----------
   * FromCharDateMode
   * ----------
   *
   * This value is used to nominate one of several distinct (and mutually
   * exclusive) date conventions that a keyword can belong to.
   */
<span class="fc" id="L362">  enum FromCharDateMode</span>
  {
<span class="fc" id="L364">    FROM_CHAR_DATE_NONE,	/* Value does not affect date mode. */</span>
<span class="fc" id="L365">    FROM_CHAR_DATE_GREGORIAN,	/* Gregorian (day, month, year) style date */</span>
<span class="fc" id="L366">    FROM_CHAR_DATE_ISOWEEK		/* ISO 8601 week date */</span>
  }

  /**
   * ----------
   * KeyWords for DATE-TIME version
   * ----------
   */
<span class="fc" id="L374">  static final Object[][] DCH_keywordValues = {</span>
      /*	name, len, id, is_digit, date_mode */
<span class="fc" id="L376">      {&quot;A.D.&quot;, 4, DCH_poz.DCH_A_D, false, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* A */</span>
<span class="fc" id="L377">      {&quot;A.M.&quot;, 4, DCH_poz.DCH_A_M, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L378">      {&quot;AD&quot;, 2, DCH_poz.DCH_AD, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L379">      {&quot;AM&quot;, 2, DCH_poz.DCH_AM, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L380">      {&quot;B.C.&quot;, 4, DCH_poz.DCH_B_C, false, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* B */</span>
<span class="fc" id="L381">      {&quot;BC&quot;, 2, DCH_poz.DCH_BC, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L382">      {&quot;CC&quot;, 2, DCH_poz.DCH_CC, true, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* C */</span>
<span class="fc" id="L383">      {&quot;DAY&quot;, 3, DCH_poz.DCH_DAY, false, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* D */</span>
<span class="fc" id="L384">      {&quot;DDD&quot;, 3, DCH_poz.DCH_DDD, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L385">      {&quot;DD&quot;, 2, DCH_poz.DCH_DD, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L386">      {&quot;DY&quot;, 2, DCH_poz.DCH_DY, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L387">      {&quot;Day&quot;, 3, DCH_poz.DCH_Day, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L388">      {&quot;Dy&quot;, 2, DCH_poz.DCH_Dy, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L389">      {&quot;D&quot;, 1, DCH_poz.DCH_D, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L390">      {&quot;FX&quot;, 2, DCH_poz.DCH_FX, false, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* F */</span>
<span class="fc" id="L391">      {&quot;HH24&quot;, 4, DCH_poz.DCH_HH24, true, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* H */</span>
<span class="fc" id="L392">      {&quot;HH12&quot;, 4, DCH_poz.DCH_HH12, true, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L393">      {&quot;HH&quot;, 2, DCH_poz.DCH_HH, true, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L394">      {&quot;IDDD&quot;, 4, DCH_poz.DCH_IDDD, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},		/* I */</span>
<span class="fc" id="L395">      {&quot;ID&quot;, 2, DCH_poz.DCH_ID, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L396">      {&quot;IW&quot;, 2, DCH_poz.DCH_IW, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L397">      {&quot;IYYY&quot;, 4, DCH_poz.DCH_IYYY, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L398">      {&quot;IYY&quot;, 3, DCH_poz.DCH_IYY, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L399">      {&quot;IY&quot;, 2, DCH_poz.DCH_IY, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L400">      {&quot;I&quot;, 1, DCH_poz.DCH_I, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L401">      {&quot;J&quot;, 1, DCH_poz.DCH_J, true, FromCharDateMode.FROM_CHAR_DATE_NONE}, /* J */</span>
<span class="fc" id="L402">      {&quot;MI&quot;, 2, DCH_poz.DCH_MI, true, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* M */</span>
<span class="fc" id="L403">      {&quot;MM&quot;, 2, DCH_poz.DCH_MM, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L404">      {&quot;MONTH&quot;, 5, DCH_poz.DCH_MONTH, false, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L405">      {&quot;MON&quot;, 3, DCH_poz.DCH_MON, false, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L406">      {&quot;MS&quot;, 2, DCH_poz.DCH_MS, true, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L407">      {&quot;Month&quot;, 5, DCH_poz.DCH_Month, false, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L408">      {&quot;Mon&quot;, 3, DCH_poz.DCH_Mon, false, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L409">      {&quot;P.M.&quot;, 4, DCH_poz.DCH_P_M, false, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* P */</span>
<span class="fc" id="L410">      {&quot;PM&quot;, 2, DCH_poz.DCH_PM, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L411">      {&quot;Q&quot;, 1, DCH_poz.DCH_Q, true, FromCharDateMode.FROM_CHAR_DATE_NONE}, /* Q */</span>
<span class="fc" id="L412">      {&quot;RM&quot;, 2, DCH_poz.DCH_RM, false, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN}, /* R */</span>
<span class="fc" id="L413">      {&quot;SSSS&quot;, 4, DCH_poz.DCH_SSSS, true, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* S */</span>
<span class="fc" id="L414">      {&quot;SS&quot;, 2, DCH_poz.DCH_SS, true, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L415">      {&quot;TZ&quot;, 2, DCH_poz.DCH_TZ, false, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* T */</span>
<span class="fc" id="L416">      {&quot;US&quot;, 2, DCH_poz.DCH_US, true, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* U */</span>
<span class="fc" id="L417">      {&quot;WW&quot;, 2, DCH_poz.DCH_WW, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},	/* W */</span>
<span class="fc" id="L418">      {&quot;W&quot;, 1, DCH_poz.DCH_W, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L419">      {&quot;Y,YYY&quot;, 5, DCH_poz.DCH_Y_YYY, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},	/* Y */</span>
<span class="fc" id="L420">      {&quot;YYYY&quot;, 4, DCH_poz.DCH_YYYY, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L421">      {&quot;YYY&quot;, 3, DCH_poz.DCH_YYY, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L422">      {&quot;YY&quot;, 2, DCH_poz.DCH_YY, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L423">      {&quot;Y&quot;, 1, DCH_poz.DCH_Y, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L424">      {&quot;a.d.&quot;, 4, DCH_poz.DCH_a_d, false, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* a */</span>
<span class="fc" id="L425">      {&quot;a.m.&quot;, 4, DCH_poz.DCH_a_m, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L426">      {&quot;ad&quot;, 2, DCH_poz.DCH_ad, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L427">      {&quot;am&quot;, 2, DCH_poz.DCH_am, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L428">      {&quot;b.c.&quot;, 4, DCH_poz.DCH_b_c, false, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* b */</span>
<span class="fc" id="L429">      {&quot;bc&quot;, 2, DCH_poz.DCH_bc, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L430">      {&quot;cc&quot;, 2, DCH_poz.DCH_CC, true, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* c */</span>
<span class="fc" id="L431">      {&quot;day&quot;, 3, DCH_poz.DCH_day, false, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* d */</span>
<span class="fc" id="L432">      {&quot;ddd&quot;, 3, DCH_poz.DCH_DDD, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L433">      {&quot;dd&quot;, 2, DCH_poz.DCH_DD, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L434">      {&quot;dy&quot;, 2, DCH_poz.DCH_dy, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L435">      {&quot;d&quot;, 1, DCH_poz.DCH_D, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L436">      {&quot;fx&quot;, 2, DCH_poz.DCH_FX, false, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* f */</span>
<span class="fc" id="L437">      {&quot;hh24&quot;, 4, DCH_poz.DCH_HH24, true, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* h */</span>
<span class="fc" id="L438">      {&quot;hh12&quot;, 4, DCH_poz.DCH_HH12, true, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L439">      {&quot;hh&quot;, 2, DCH_poz.DCH_HH, true, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L440">      {&quot;iddd&quot;, 4, DCH_poz.DCH_IDDD, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},		/* i */</span>
<span class="fc" id="L441">      {&quot;id&quot;, 2, DCH_poz.DCH_ID, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L442">      {&quot;iw&quot;, 2, DCH_poz.DCH_IW, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L443">      {&quot;iyyy&quot;, 4, DCH_poz.DCH_IYYY, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L444">      {&quot;iyy&quot;, 3, DCH_poz.DCH_IYY, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L445">      {&quot;iy&quot;, 2, DCH_poz.DCH_IY, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L446">      {&quot;i&quot;, 1, DCH_poz.DCH_I, true, FromCharDateMode.FROM_CHAR_DATE_ISOWEEK},</span>
<span class="fc" id="L447">      {&quot;j&quot;, 1, DCH_poz.DCH_J, true, FromCharDateMode.FROM_CHAR_DATE_NONE}, /* j */</span>
<span class="fc" id="L448">      {&quot;mi&quot;, 2, DCH_poz.DCH_MI, true, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* m */</span>
<span class="fc" id="L449">      {&quot;mm&quot;, 2, DCH_poz.DCH_MM, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L450">      {&quot;month&quot;, 5, DCH_poz.DCH_month, false, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L451">      {&quot;mon&quot;, 3, DCH_poz.DCH_mon, false, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L452">      {&quot;ms&quot;, 2, DCH_poz.DCH_MS, true, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L453">      {&quot;p.m.&quot;, 4, DCH_poz.DCH_p_m, false, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* p */</span>
<span class="fc" id="L454">      {&quot;pm&quot;, 2, DCH_poz.DCH_pm, false, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L455">      {&quot;q&quot;, 1, DCH_poz.DCH_Q, true, FromCharDateMode.FROM_CHAR_DATE_NONE}, /* q */</span>
<span class="fc" id="L456">      {&quot;rm&quot;, 2, DCH_poz.DCH_rm, false, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN}, /* r */</span>
<span class="fc" id="L457">      {&quot;ssss&quot;, 4, DCH_poz.DCH_SSSS, true, FromCharDateMode.FROM_CHAR_DATE_NONE},	/* s */</span>
<span class="fc" id="L458">      {&quot;ss&quot;, 2, DCH_poz.DCH_SS, true, FromCharDateMode.FROM_CHAR_DATE_NONE},</span>
<span class="fc" id="L459">      {&quot;tz&quot;, 2, DCH_poz.DCH_tz, false, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* t */</span>
<span class="fc" id="L460">      {&quot;us&quot;, 2, DCH_poz.DCH_US, true, FromCharDateMode.FROM_CHAR_DATE_NONE},		/* u */</span>
<span class="fc" id="L461">      {&quot;ww&quot;, 2, DCH_poz.DCH_WW, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},	/* w */</span>
<span class="fc" id="L462">      {&quot;w&quot;, 1, DCH_poz.DCH_W, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L463">      {&quot;y,yyy&quot;, 5, DCH_poz.DCH_Y_YYY, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},	/* y */</span>
<span class="fc" id="L464">      {&quot;yyyy&quot;, 4, DCH_poz.DCH_YYYY, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L465">      {&quot;yyy&quot;, 3, DCH_poz.DCH_YYY, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L466">      {&quot;yy&quot;, 2, DCH_poz.DCH_YY, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN},</span>
<span class="fc" id="L467">      {&quot;y&quot;, 1, DCH_poz.DCH_Y, true, FromCharDateMode.FROM_CHAR_DATE_GREGORIAN}</span>
  };

<span class="fc" id="L470">  static final KeyWord[] DCH_keywords = new KeyWord[DCH_keywordValues.length];</span>

<span class="fc" id="L472">  static Map&lt;Character, Integer&gt; DCH_index = new HashMap&lt;&gt;();</span>

  static {
<span class="fc" id="L475">    int index = 0;</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">    for(Object[] eachKeywordValue: DCH_keywordValues) {</span>
<span class="fc" id="L477">      KeyWord keyword = new KeyWord();</span>
<span class="fc" id="L478">      keyword.name = (String)eachKeywordValue[0];</span>
<span class="fc" id="L479">      keyword.len = ((Integer)eachKeywordValue[1]).intValue();</span>
<span class="fc" id="L480">      keyword.idType = ((DCH_poz)eachKeywordValue[2]);</span>
<span class="fc" id="L481">      keyword.is_digit = ((Boolean)eachKeywordValue[3]).booleanValue();</span>
<span class="fc" id="L482">      keyword.date_mode = (FromCharDateMode)eachKeywordValue[4];</span>

<span class="fc" id="L484">      Character c = Character.valueOf(keyword.name.charAt(0));</span>
<span class="fc" id="L485">      Integer pos = DCH_index.get(c);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">      if (pos == null) {</span>
<span class="fc" id="L487">        DCH_index.put(c, index);</span>
      }
<span class="fc" id="L489">      DCH_keywords[index++] = keyword;</span>
    }
  }

  /**
   * ----------
   * Format parser structs
   * ----------
   */
  static class KeySuffix {
    String name;			/* suffix string		*/
    int len;			    /* suffix length		*/
    int id;				    /* used in node-&gt;suffix */
    int type;			    /* prefix / postfix			*/

<span class="fc" id="L504">    public KeySuffix(String name, int len, int id, int type) {</span>
<span class="fc" id="L505">      this.name = name;</span>
<span class="fc" id="L506">      this.len = len;</span>
<span class="fc" id="L507">      this.id = id;</span>
<span class="fc" id="L508">      this.type = type;</span>
<span class="fc" id="L509">    }</span>
  }

<span class="fc" id="L512">  static class KeyWord {</span>
    String name;
    int len;
    DCH_poz idType;
    boolean is_digit;
    FromCharDateMode date_mode;
  }

<span class="fc" id="L520">  static class FormatNode {</span>
    int type;			  /* node type			*/
    KeyWord key;		/* if node type is KEYWORD	*/
    char character;	/* if node type is CHAR		*/
    int suffix;			/* keyword suffix		*/
  }

<span class="fc" id="L527">  static class TmFromChar {</span>
<span class="fc" id="L528">    FromCharDateMode mode = FromCharDateMode.FROM_CHAR_DATE_NONE;</span>
    int	hh;
    int pm;
    int mi;
    int ss;
    int ssss;
    int d;				/* stored as 1-7, Sunday = 1, 0 means missing */
    int dd;
    int ddd;
    int mm;
    int ms;
    int year;
    int bc;
    int ww;
    int w;
    int cc;
    int j;
    int us;
    int yysz;			/* is it YY or YYYY ? */
    int clock;		/* 12 or 24 hour clock? */
  }
<span class="fc" id="L549">  static Map&lt;String, FormatNode[]&gt; formatNodeCache = new HashMap&lt;&gt;();</span>

 /**
  * ----------
  * Skip TM / th in FROM_CHAR
  * ----------
  */
  static int SKIP_THth(int suf)	{
<span class="nc bnc" id="L557" title="All 2 branches missed.">    return (S_THth(suf) != 0 ? 2 : 0);</span>
  }

  /**
   * ----------
   * Suffix tests
   * ----------
   */
  static int S_THth(int s) {
<span class="pc bpc" id="L566" title="2 of 4 branches missed.">    return ((((s) &amp; DCH_S_TH) != 0 || ((s) &amp; DCH_S_th) != 0) ? 1 : 0);</span>
  }
  static int S_TH(int s) {
<span class="nc bnc" id="L569" title="All 2 branches missed.">    return (((s) &amp; DCH_S_TH) != 0 ? 1 : 0);</span>
  }
  static int S_th(int s) {
<span class="nc bnc" id="L572" title="All 2 branches missed.">    return (((s) &amp; DCH_S_th) != 0 ? 1 : 0);</span>
  }
  static int S_TH_TYPE(int s) {
<span class="nc bnc" id="L575" title="All 2 branches missed.">    return (((s) &amp; DCH_S_TH) != 0 ? TH_UPPER : TH_LOWER);</span>
  }

  static final int TH_UPPER	=	1;
  static final int TH_LOWER = 2;

  /* Oracle toggles FM behavior, we don't; see docs. */
  static int S_FM(int s) {
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">    return (((s) &amp; DCH_S_FM) != 0 ? 1 : 0);</span>
  }
  static int S_SP(int s) {
<span class="nc bnc" id="L586" title="All 2 branches missed.">    return (((s) &amp; DCH_S_SP) != 0 ? 1 : 0);</span>
  }
  static int S_TM(int s) {
<span class="nc bnc" id="L589" title="All 2 branches missed.">    return (((s) &amp; DCH_S_TM) != 0 ? 1 : 0);</span>
  }

  public static TimeMeta parseDateTime(String dateText, String formatText) {
<span class="fc" id="L593">    TimeMeta tm = new TimeMeta();</span>

    //TODO consider TimeZone
<span class="nc" id="L596">    doToTimestamp(dateText, formatText, tm);</span>

    // when we parse some date without day like '2014-04', we should set day to 1.
<span class="nc bnc" id="L599" title="All 2 branches missed.">    if (tm.dayOfMonth == 0) {</span>
<span class="nc" id="L600">      tm.dayOfMonth = 1;</span>
    }

<span class="nc bnc" id="L603" title="All 4 branches missed.">    if (tm.dayOfYear &gt; 0 &amp;&amp; tm.dayOfMonth &gt; 0) {</span>
<span class="nc" id="L604">      tm.dayOfYear = 0;</span>
    }

<span class="nc" id="L607">    return tm;</span>
  }

  /**
   * Make Timestamp from date_str which is formatted at argument 'fmt'
   * ( toTimestamp is reverse to_char() )
   * @param dateText
   * @param formatText
   * @return
   */
  public static TimestampDatum toTimestamp(String dateText, String formatText) {
<span class="nc" id="L618">    TimeMeta tm = parseDateTime(dateText, formatText);</span>

<span class="nc" id="L620">    return new TimestampDatum(DateTimeUtil.toJulianTimestamp(tm));</span>
  }

  /**
   * Parse the 'dateText' according to 'formatText', return results as a TimeMeta tm
   * and fractional seconds.
   *
   * We parse 'formatText' into a list of FormatNodes, which is then passed to
   * DCH_from_char to populate a TmFromChar with the parsed contents of
   * 'dateText'.
   *
   * The TmFromChar is then analysed and converted into the final results in struct 'tm'.
   *
   * This function does very little error checking, e.g.
   * to_timestamp('20096040','YYYYMMDD') works
   * @param dateText
   * @param formatText
   * @param tm
   */
  static void doToTimestamp(String dateText, String formatText, TimeMeta tm) {
<span class="fc" id="L640">    TmFromChar tmfc = new TmFromChar();</span>
<span class="fc" id="L641">    int formatLength = formatText.length();</span>

<span class="pc bpc" id="L643" title="1 of 2 branches missed.">    if (formatLength &gt; 0) {</span>
      FormatNode[] formatNodes;
<span class="fc" id="L645">      synchronized(formatNodeCache) {</span>
<span class="fc" id="L646">        formatNodes = formatNodeCache.get(formatText);</span>
<span class="fc" id="L647">      }</span>

<span class="fc bfc" id="L649" title="All 2 branches covered.">      if (formatNodes == null) {</span>
<span class="fc" id="L650">        formatNodes = new FormatNode[formatLength + 1];</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">        for (int i = 0; i &lt; formatNodes.length; i++) {</span>
<span class="fc" id="L652">          formatNodes[i] = new FormatNode();</span>
        }
<span class="fc" id="L654">        parseFormat(formatNodes, formatText, FORMAT_TYPE.DCH_TYPE);</span>
<span class="fc" id="L655">        formatNodes[formatLength].type = NODE_TYPE_END;	/* Paranoia? */</span>

<span class="fc" id="L657">        synchronized(formatNodeCache) {</span>
<span class="fc" id="L658">          formatNodeCache.put(formatText, formatNodes);</span>
<span class="fc" id="L659">        }</span>
      }
<span class="nc" id="L661">      DCH_from_char(formatNodes, dateText, tmfc);</span>
    }

    /*
     * Convert values that user define for FROM_CHAR (to_date/to_timestamp) to
     * standard 'tm'
     */
<span class="nc bnc" id="L668" title="All 2 branches missed.">    if (tmfc.ssss != 0) {</span>
<span class="nc" id="L669">      int x = tmfc.ssss;</span>

<span class="nc" id="L671">      tm.hours = x / DateTimeConstants.SECS_PER_HOUR;</span>
<span class="nc" id="L672">      x %= DateTimeConstants.SECS_PER_HOUR;</span>
<span class="nc" id="L673">      tm.minutes = x / DateTimeConstants.SECS_PER_MINUTE;</span>
<span class="nc" id="L674">      x %= DateTimeConstants.SECS_PER_MINUTE;</span>
<span class="nc" id="L675">      tm.secs = x;</span>
    }

<span class="nc bnc" id="L678" title="All 2 branches missed.">    if (tmfc.ss != 0) {</span>
<span class="nc" id="L679">      tm.secs = tmfc.ss;</span>
    }
<span class="nc bnc" id="L681" title="All 2 branches missed.">    if (tmfc.mi != 0) {</span>
<span class="nc" id="L682">      tm.minutes = tmfc.mi;</span>
    }
<span class="nc bnc" id="L684" title="All 2 branches missed.">    if (tmfc.hh != 0) {</span>
<span class="nc" id="L685">      tm.hours = tmfc.hh;</span>
    }

<span class="nc bnc" id="L688" title="All 2 branches missed.">    if (tmfc.clock == CLOCK_12_HOUR) {</span>
<span class="nc bnc" id="L689" title="All 4 branches missed.">      if (tm.hours &lt; 1 || tm.hours &gt; HOURS_PER_DAY / 2) {</span>
<span class="nc" id="L690">        throw new IllegalArgumentException(</span>
            &quot;hour \&quot;&quot; + tm.hours + &quot;\&quot; is invalid for the 12-hour clock, &quot; +
                &quot;Use the 24-hour clock, or give an hour between 1 and 12.&quot;);
      }
<span class="nc bnc" id="L694" title="All 4 branches missed.">      if (tmfc.pm != 0 &amp;&amp; tm.hours &lt; HOURS_PER_DAY / 2) {</span>
<span class="nc" id="L695">        tm.hours += HOURS_PER_DAY / 2;</span>
<span class="nc bnc" id="L696" title="All 4 branches missed.">      } else if (tmfc.pm == 0 &amp;&amp; tm.hours == HOURS_PER_DAY / 2) {</span>
<span class="nc" id="L697">        tm.hours = 0;</span>
      }
    }

<span class="nc bnc" id="L701" title="All 2 branches missed.">    if (tmfc.year != 0) {</span>
      /*
       * If CC and YY (or Y) are provided, use YY as 2 low-order digits for
       * the year in the given century.  Keep in mind that the 21st century
       * AD runs from 2001-2100, not 2000-2099; 6th century BC runs from
       * 600BC to 501BC.
       */
<span class="nc bnc" id="L708" title="All 4 branches missed.">      if (tmfc.cc != 0 &amp;&amp; tmfc.yysz &lt;= 2) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (tmfc.bc != 0) {</span>
<span class="nc" id="L710">          tmfc.cc = -tmfc.cc;</span>
        }
<span class="nc" id="L712">        tm.years = tmfc.year % 100;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (tm.years != 0) {</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">          if (tmfc.cc &gt;= 0) {</span>
<span class="nc" id="L715">            tm.years += (tmfc.cc - 1) * 100;</span>
          } else {
<span class="nc" id="L717">            tm.years = (tmfc.cc + 1) * 100 - tm.years + 1;</span>
          }
        } else {
				  /* find century year for dates ending in &quot;00&quot; */
<span class="nc bnc" id="L721" title="All 2 branches missed.">          tm.years = tmfc.cc * 100 + ((tmfc.cc &gt;= 0) ? 0 : 1);</span>
        }
      } else {
			  /* If a 4-digit year is provided, we use that and ignore CC. */
<span class="nc" id="L725">        tm.years = tmfc.year;</span>
<span class="nc bnc" id="L726" title="All 4 branches missed.">        if (tmfc.bc != 0 &amp;&amp; tm.years &gt; 0) {</span>
<span class="nc" id="L727">          tm.years = -(tm.years - 1);</span>
        }
      }
    }
<span class="nc bnc" id="L731" title="All 2 branches missed.">    else if (tmfc.cc != 0) {			/* use first year of century */</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">      if (tmfc.bc != 0) {</span>
<span class="nc" id="L733">        tmfc.cc = -tmfc.cc;</span>
      }
<span class="nc bnc" id="L735" title="All 2 branches missed.">      if (tmfc.cc &gt;= 0) {</span>
			  /* +1 because 21st century started in 2001 */
<span class="nc" id="L737">        tm.years = (tmfc.cc - 1) * 100 + 1;</span>
      } else {
			  /* +1 because year == 599 is 600 BC */
<span class="nc" id="L740">        tm.years = tmfc.cc * 100 + 1;</span>
      }
    }

<span class="nc bnc" id="L744" title="All 2 branches missed.">    if (tmfc.j != 0) {</span>
<span class="nc" id="L745">      DateTimeUtil.j2date(tmfc.j, tm);</span>
    }
<span class="nc bnc" id="L747" title="All 2 branches missed.">    if (tmfc.ww != 0) {</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">      if (tmfc.mode == FromCharDateMode.FROM_CHAR_DATE_ISOWEEK) {</span>
        /*
         * If tmfc.d is not set, then the date is left at the beginning of
         * the ISO week (Monday).
         */
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (tmfc.d != 0) {</span>
<span class="nc" id="L754">          DateTimeUtil.isoweekdate2date(tmfc.ww, tmfc.d, tm);</span>
        } else {
<span class="nc" id="L756">          DateTimeUtil.isoweek2date(tmfc.ww, tm);</span>
        }
      } else {
<span class="nc" id="L759">        tmfc.ddd = (tmfc.ww - 1) * 7 + 1;</span>
      }
    }

<span class="nc bnc" id="L763" title="All 2 branches missed.">    if (tmfc.w != 0) {</span>
<span class="nc" id="L764">      tmfc.dd = (tmfc.w - 1) * 7 + 1;</span>
    }
<span class="nc bnc" id="L766" title="All 2 branches missed.">    if (tmfc.d != 0) {</span>
      //tm.tm_wday = tmfc.d - 1;		/* convert to native numbering */
    }
<span class="nc bnc" id="L769" title="All 2 branches missed.">    if (tmfc.dd != 0) {</span>
<span class="nc" id="L770">      tm.dayOfMonth = tmfc.dd;</span>
    }
<span class="nc bnc" id="L772" title="All 2 branches missed.">    if (tmfc.ddd != 0) {</span>
<span class="nc" id="L773">      tm.dayOfYear = tmfc.ddd;</span>
    }
<span class="nc bnc" id="L775" title="All 2 branches missed.">    if (tmfc.mm != 0) {</span>
<span class="nc" id="L776">      tm.monthOfYear = tmfc.mm;</span>
    }
<span class="nc bnc" id="L778" title="All 6 branches missed.">    if (tmfc.ddd != 0 &amp;&amp; (tm.monthOfYear &lt;= 1 || tm.dayOfMonth &lt;= 1)) {</span>
      /*
       * The month and day field have not been set, so we use the
       * day-of-year field to populate them.	Depending on the date mode,
       * this field may be interpreted as a Gregorian day-of-year, or an ISO
       * week date day-of-year.
       */
<span class="nc bnc" id="L785" title="All 4 branches missed.">      if (tm.years == 0 &amp;&amp; tmfc.bc == 0) {</span>
<span class="nc" id="L786">        throw new IllegalArgumentException(&quot;cannot calculate day of year without year information&quot;);</span>
      }
<span class="nc bnc" id="L788" title="All 2 branches missed.">      if (tmfc.mode == FromCharDateMode.FROM_CHAR_DATE_ISOWEEK) {</span>
        /* zeroth day of the ISO year, in Julian */
<span class="nc" id="L790">        int j0 = DateTimeUtil.isoweek2j(tm.years, 1) - 1;</span>
<span class="nc" id="L791">        DateTimeUtil.j2date(j0 + tmfc.ddd, tm);</span>
<span class="nc" id="L792">      } else {</span>
        int	i;

<span class="nc" id="L795">        boolean leap = DateTimeUtil.isLeapYear(tm.years);</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">        int[] y = ysum[leap ? 1 : 0];</span>

<span class="nc bnc" id="L798" title="All 2 branches missed.">        for (i = 1; i &lt;= MONTHS_PER_YEAR; i++) {</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">          if (tmfc.ddd &lt; y[i])</span>
<span class="nc" id="L800">            break;</span>
        }
<span class="nc bnc" id="L802" title="All 2 branches missed.">        if (tm.monthOfYear &lt;= 1) {</span>
<span class="nc" id="L803">          tm.monthOfYear = i;</span>
        }

<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (tm.dayOfMonth &lt;= 1) {</span>
<span class="nc" id="L807">          tm.dayOfMonth = tmfc.ddd - y[i - 1];</span>
        }
<span class="nc" id="L809">        tm.dayOfYear = 0;</span>
      }
    }

<span class="nc bnc" id="L813" title="All 2 branches missed.">    if (tmfc.ms != 0) {</span>
<span class="nc" id="L814">      tm.fsecs += tmfc.ms * 1000;</span>
    }
<span class="nc bnc" id="L816" title="All 2 branches missed.">    if (tmfc.us != 0) {</span>
<span class="nc" id="L817">      tm.fsecs += tmfc.us;</span>
    }
<span class="nc" id="L819">  }</span>

  /**
   * Format parser, search small keywords and keyword's suffixes, and make
   * format-node tree.
   *
   * for DATE-TIME &amp; NUMBER version
   * @param node
   * @param str
   * @param ver
   */
  static void parseFormat(FormatNode[] node, String str, FORMAT_TYPE ver) {
    KeySuffix  s;
<span class="fc" id="L832">    boolean	node_set = false;</span>
    int suffix;
<span class="fc" id="L834">    int last = 0;</span>

<span class="fc" id="L836">    int nodeIndex = 0;</span>
<span class="fc" id="L837">    int charIdx = 0;</span>
<span class="fc" id="L838">    char[] chars = str.toCharArray();</span>

<span class="fc bfc" id="L840" title="All 2 branches covered.">    while (charIdx &lt; chars.length) {</span>
<span class="fc" id="L841">      suffix = 0;</span>

      // Prefix
<span class="pc bpc" id="L844" title="2 of 4 branches missed.">      if (ver == FORMAT_TYPE.DCH_TYPE &amp;&amp; (s = suff_search(chars, charIdx, SUFFTYPE_PREFIX)) != null) {</span>
<span class="nc" id="L845">        suffix |= s.id;</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (s.len &gt; 0) {</span>
<span class="nc" id="L847">          charIdx += s.len;</span>
        }
      }

      // Keyword
<span class="pc bpc" id="L852" title="1 of 4 branches missed.">      if (charIdx &lt; chars.length &amp;&amp; (node[nodeIndex].key = index_seq_search(chars, charIdx)) != null) {</span>
<span class="fc" id="L853">        node[nodeIndex].type = NODE_TYPE_ACTION;</span>
<span class="fc" id="L854">        node[nodeIndex].suffix = 0;</span>
<span class="fc" id="L855">        node_set = true;</span>
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">        if (node[nodeIndex].key.len &gt; 0) {</span>
<span class="fc" id="L857">          charIdx += node[nodeIndex].key.len;</span>
        }

        // NUM version: Prepare global NUMDesc struct
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (ver == FORMAT_TYPE.NUM_TYPE) {</span>
          //NUMDesc_prepare(Num, node);
        }

         // Postfix
<span class="pc bpc" id="L866" title="2 of 6 branches missed.">        if (ver == FORMAT_TYPE.DCH_TYPE &amp;&amp; charIdx &lt; chars.length  &amp;&amp; (s = suff_search(chars, charIdx, SUFFTYPE_POSTFIX)) != null) {</span>
<span class="nc" id="L867">          suffix |= s.id;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">          if (s.len &gt; 0) {</span>
<span class="nc" id="L869">            charIdx += s.len;</span>
          }
        }
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">      } else if (charIdx &lt; chars.length) {</span>
        // Special characters '\' and '&quot;'
<span class="pc bpc" id="L874" title="3 of 4 branches missed.">        if (chars[charIdx] == '&quot;' &amp;&amp; last != '\\') {</span>
<span class="nc" id="L875">          int			x = 0;</span>

<span class="nc bnc" id="L877" title="All 2 branches missed.">          while (charIdx &lt; chars.length ) {</span>
<span class="nc" id="L878">            charIdx++;</span>
<span class="nc bnc" id="L879" title="All 4 branches missed.">            if (chars[charIdx] == '&quot;' &amp;&amp; x != '\\') {</span>
<span class="nc" id="L880">              charIdx++;</span>
<span class="nc" id="L881">              break;</span>
<span class="nc bnc" id="L882" title="All 4 branches missed.">            } else if (chars[charIdx] == '\\' &amp;&amp; x != '\\') {</span>
<span class="nc" id="L883">              x = '\\';</span>
<span class="nc" id="L884">              continue;</span>
            }
<span class="nc" id="L886">            node[nodeIndex].type = NODE_TYPE_CHAR;</span>
<span class="nc" id="L887">            node[nodeIndex].character = chars[charIdx];</span>
<span class="nc" id="L888">            node[nodeIndex].key = null;</span>
<span class="nc" id="L889">            node[nodeIndex].suffix = 0;</span>
<span class="nc" id="L890">            nodeIndex++;</span>
<span class="nc" id="L891">            x = chars[charIdx];</span>
          }
<span class="nc" id="L893">          node_set = false;</span>
<span class="nc" id="L894">          suffix = 0;</span>
<span class="nc" id="L895">          last = 0;</span>
<span class="pc bpc" id="L896" title="6 of 8 branches missed.">        } else if (charIdx &lt; chars.length - 1 &amp;&amp; chars[charIdx] == '\\' &amp;&amp; last != '\\' &amp;&amp; chars[charIdx + 1] == '&quot;') {</span>
<span class="nc" id="L897">          last = chars[charIdx];</span>
<span class="nc" id="L898">          charIdx++;</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">        } else if (charIdx &lt; chars.length) {</span>
<span class="fc" id="L900">          node[nodeIndex].type = NODE_TYPE_CHAR;</span>
<span class="fc" id="L901">          node[nodeIndex].character = chars[charIdx];</span>
<span class="fc" id="L902">          node[nodeIndex].key = null;</span>
<span class="fc" id="L903">          node_set = true;</span>
<span class="fc" id="L904">          last = 0;</span>
<span class="fc" id="L905">          charIdx++;</span>
        }
      }

		  // end
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">      if (node_set) {</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">        if (node[nodeIndex].type == NODE_TYPE_ACTION) {</span>
<span class="fc" id="L912">          node[nodeIndex].suffix = suffix;</span>
        }
<span class="fc" id="L914">        nodeIndex++;</span>
<span class="fc" id="L915">        node[nodeIndex].suffix = 0;</span>
<span class="fc" id="L916">        node_set = false;</span>
      }
    }

<span class="fc" id="L920">    node[nodeIndex].type = NODE_TYPE_END;</span>
<span class="fc" id="L921">    node[nodeIndex].suffix = 0;</span>
<span class="fc" id="L922">  }</span>

  /**
   * Process a string as denoted by a list of FormatNodes.
   * The TmFromChar struct pointed to by 'out' is populated with the results.
   *
   * Note: we currently don't have any to_interval() function, so there
   * is no need here for INVALID_FOR_INTERVAL checks.
   * @param nodes
   * @param dateText
   * @param out
   */
  static void DCH_from_char(FormatNode[] nodes, String dateText, TmFromChar out) {
    int	len;
<span class="fc" id="L936">    AtomicInteger value = new AtomicInteger();</span>
<span class="fc" id="L937">    boolean	fx_mode = false;</span>

<span class="fc" id="L939">    char[] chars = dateText.toCharArray();</span>
<span class="fc" id="L940">    int charIdx = 0;</span>
<span class="fc" id="L941">    int nodeIdx = 0;</span>
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">    for (; nodeIdx &lt; nodes.length; nodeIdx++) {</span>
<span class="fc" id="L943">      FormatNode node = nodes[nodeIdx];</span>
<span class="pc bpc" id="L944" title="2 of 4 branches missed.">      if (node.type == NODE_TYPE_END || charIdx &gt;= chars.length) {</span>
<span class="nc" id="L945">        break;</span>
      }
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">      if (node.type != NODE_TYPE_ACTION) {</span>
<span class="nc" id="L948">        charIdx++;</span>
			  /* Ignore spaces when not in FX (fixed width) mode */
<span class="nc bnc" id="L950" title="All 4 branches missed.">        if (Character.isSpaceChar(node.character) &amp;&amp; !fx_mode) {</span>
<span class="nc bnc" id="L951" title="All 4 branches missed.">          while (charIdx &lt; chars.length &amp;&amp; Character.isSpaceChar(chars[charIdx])) {</span>
<span class="nc" id="L952">            charIdx++;</span>
          }
        }
        continue;
      }

<span class="fc" id="L958">      from_char_set_mode(out, node.key.date_mode);</span>

<span class="pc bpc" id="L960" title="35 of 36 branches missed.">      switch (node.key.idType) {</span>
        case DCH_FX:
<span class="nc" id="L962">          fx_mode = true;</span>
<span class="nc" id="L963">          break;</span>
        case DCH_A_M:
        case DCH_P_M:
        case DCH_a_m:
        case DCH_p_m:
<span class="nc" id="L968">          value.set(out.pm);</span>
<span class="nc" id="L969">          charIdx += from_char_seq_search(value, dateText, charIdx, ampm_strings_long, ALL_UPPER, node.key.len, node);</span>
<span class="nc" id="L970">          assertOutValue(out.pm, value.get() % 2, node);</span>
<span class="nc" id="L971">          out.pm = value.get() % 2;</span>
<span class="nc" id="L972">          out.clock = CLOCK_12_HOUR;</span>
<span class="nc" id="L973">          break;</span>
        case DCH_AM:
        case DCH_PM:
        case DCH_am:
        case DCH_pm:
<span class="nc" id="L978">          value.set(out.pm);</span>
<span class="nc" id="L979">          charIdx += from_char_seq_search(value, dateText, charIdx, ampm_strings, ALL_UPPER, node.key.len, node);</span>
<span class="nc" id="L980">          assertOutValue(out.pm, value.get() % 2, node);</span>
<span class="nc" id="L981">          out.pm = value.get() % 2;</span>
<span class="nc" id="L982">          out.clock = CLOCK_12_HOUR;</span>
<span class="nc" id="L983">          break;</span>
        case DCH_HH:
        case DCH_HH12:
<span class="nc" id="L986">          value.set(out.hh);</span>
<span class="nc" id="L987">          charIdx += from_char_parse_int_len(value, dateText, charIdx, 2, nodes, nodeIdx);</span>
<span class="nc" id="L988">          out.hh = value.get();</span>
<span class="nc" id="L989">          out.clock = CLOCK_12_HOUR;</span>
<span class="nc" id="L990">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L991">          break;</span>
        case DCH_HH24:
<span class="fc" id="L993">          value.set(out.hh);</span>
<span class="nc" id="L994">          charIdx += from_char_parse_int_len(value, dateText, charIdx, 2, nodes, nodeIdx);</span>
<span class="nc" id="L995">          out.hh = value.get();</span>
<span class="nc" id="L996">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L997">          break;</span>
        case DCH_MI:
<span class="nc" id="L999">          value.set(out.mi);</span>
<span class="nc" id="L1000">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1001">          out.mi = value.get();</span>
<span class="nc" id="L1002">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1003">          break;</span>
        case DCH_SS:
<span class="nc" id="L1005">          value.set(out.ss);</span>
<span class="nc" id="L1006">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1007">          out.ss = value.get();</span>
<span class="nc" id="L1008">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1009">          break;</span>
        case DCH_MS:		/* millisecond */
<span class="nc" id="L1011">          value.set(out.ms);</span>
<span class="nc" id="L1012">          len = from_char_parse_int_len(value, dateText, charIdx, 3, nodes, nodeIdx);</span>
<span class="nc" id="L1013">          charIdx += len;</span>
<span class="nc" id="L1014">          out.ms = value.get();</span>
          /*
           * 25 is 0.25 and 250 is 0.25 too; 025 is 0.025 and not 0.25
           */
<span class="nc bnc" id="L1018" title="All 4 branches missed.">          out.ms *= len == 1 ? 100 :</span>
              len == 2 ? 10 : 1;

<span class="nc" id="L1021">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1022">          break;</span>
        case DCH_US:		/* microsecond */
<span class="nc" id="L1024">          value.set(out.us);</span>
<span class="nc" id="L1025">          len = from_char_parse_int_len(value, dateText, charIdx, 6, nodes, nodeIdx);</span>
<span class="nc" id="L1026">          charIdx += len;</span>
<span class="nc" id="L1027">          out.us = value.get();</span>
<span class="nc bnc" id="L1028" title="All 10 branches missed.">          out.us *= len == 1 ? 100000 :</span>
              len == 2 ? 10000 :
                  len == 3 ? 1000 :
                      len == 4 ? 100 :
                          len == 5 ? 10 : 1;

<span class="nc" id="L1034">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1035">          break;</span>
        case DCH_SSSS:
<span class="nc" id="L1037">          value.set(out.ssss);</span>
<span class="nc" id="L1038">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1039">          out.ssss = value.get();</span>
<span class="nc" id="L1040">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1041">          break;</span>
        case DCH_tz:
        case DCH_TZ:
<span class="nc" id="L1044">          throw new IllegalArgumentException(&quot;\&quot;TZ\&quot;/\&quot;tz\&quot; format patterns are not supported in to_date&quot;);</span>
        case DCH_A_D:
        case DCH_B_C:
        case DCH_a_d:
        case DCH_b_c:
<span class="nc" id="L1049">          value.set(out.bc);</span>
<span class="nc" id="L1050">          charIdx += from_char_seq_search(value, dateText, charIdx, adbc_strings_long, ALL_UPPER, node.key.len, node);</span>
<span class="nc" id="L1051">          assertOutValue(out.bc, value.get() % 2, node);</span>
<span class="nc" id="L1052">          out.bc = value.get() % 2;</span>
<span class="nc" id="L1053">          break;</span>
        case DCH_AD:
        case DCH_BC:
        case DCH_ad:
        case DCH_bc:
<span class="nc" id="L1058">          value.set(out.bc);</span>
<span class="nc" id="L1059">          charIdx += from_char_seq_search(value, dateText, charIdx, adbc_strings, ALL_UPPER, node.key.len, node);</span>
<span class="nc" id="L1060">          assertOutValue(out.bc, value.get() % 2, node);</span>
<span class="nc" id="L1061">          out.bc = value.get() % 2;</span>
<span class="nc" id="L1062">          break;</span>
        case DCH_MONTH:
        case DCH_Month:
        case DCH_month:
<span class="nc" id="L1066">          value.set(out.mm);</span>
<span class="nc" id="L1067">          charIdx += from_char_seq_search(value, dateText, charIdx, months_full, ONE_UPPER, MAX_MONTH_LEN, node);</span>
<span class="nc" id="L1068">          assertOutValue(out.mm, value.get() + 1, node);</span>
<span class="nc" id="L1069">          out.mm = value.get() + 1;</span>
<span class="nc" id="L1070">          break;</span>
        case DCH_MON:
        case DCH_Mon:
        case DCH_mon:
<span class="nc" id="L1074">          value.set(out.mm);</span>
<span class="nc" id="L1075">          charIdx += from_char_seq_search(value, dateText, charIdx, months_short, ONE_UPPER, MAX_MON_LEN, node);</span>
<span class="nc" id="L1076">          assertOutValue(out.mm, value.get() + 1, node);</span>
<span class="nc" id="L1077">          out.mm = value.get() + 1;</span>
<span class="nc" id="L1078">          break;</span>
        case DCH_MM:
<span class="nc" id="L1080">          value.set(out.mm);</span>
<span class="nc" id="L1081">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1082">          out.mm = value.get();</span>
<span class="nc" id="L1083">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1084">          break;</span>
        case DCH_DAY:
        case DCH_Day:
        case DCH_day:
<span class="nc" id="L1088">          value.set(out.d);</span>
<span class="nc" id="L1089">          charIdx += from_char_seq_search(value, dateText, charIdx, days_full, ONE_UPPER, MAX_DAY_LEN, node);</span>
<span class="nc" id="L1090">          assertOutValue(out.d, value.get(), node);</span>
<span class="nc" id="L1091">          out.d = value.get();</span>
<span class="nc" id="L1092">          out.d++;</span>
<span class="nc" id="L1093">          break;</span>
        case DCH_DY:
        case DCH_Dy:
        case DCH_dy:
<span class="nc" id="L1097">          value.set(out.d);</span>
<span class="nc" id="L1098">          charIdx += from_char_seq_search(value, dateText, charIdx, days_full, ONE_UPPER, MAX_DY_LEN, node);</span>
<span class="nc" id="L1099">          assertOutValue(out.d, value.get(), node);</span>
<span class="nc" id="L1100">          out.d = value.get();</span>
<span class="nc" id="L1101">          out.d++;</span>
<span class="nc" id="L1102">          break;</span>
        case DCH_DDD:
<span class="nc" id="L1104">          value.set(out.ddd);</span>
<span class="nc" id="L1105">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1106">          out.ddd = value.get();</span>
<span class="nc" id="L1107">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1108">          break;</span>
        case DCH_IDDD:
<span class="nc" id="L1110">          value.set(out.ddd);</span>
<span class="nc" id="L1111">          charIdx += from_char_parse_int_len(value, dateText, charIdx, 3, nodes, nodeIdx);</span>
<span class="nc" id="L1112">          out.ddd = value.get();</span>
<span class="nc" id="L1113">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1114">          break;</span>
        case DCH_DD:
<span class="nc" id="L1116">          value.set(out.dd);</span>
<span class="nc" id="L1117">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1118">          out.dd = value.get();</span>
<span class="nc" id="L1119">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1120">          break;</span>
        case DCH_D:
<span class="nc" id="L1122">          value.set(out.d);</span>
<span class="nc" id="L1123">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1124">          out.d = value.get();</span>
<span class="nc" id="L1125">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1126">          break;</span>
        case DCH_ID:
<span class="nc" id="L1128">          value.set(out.d);</span>
<span class="nc" id="L1129">          charIdx += from_char_parse_int_len(value, dateText, charIdx, 1, nodes, nodeIdx);</span>
<span class="nc" id="L1130">          out.d = value.get();</span>
				  /* Shift numbering to match Gregorian where Sunday = 1 */
<span class="nc bnc" id="L1132" title="All 2 branches missed.">          if (++out.d &gt; 7) {</span>
<span class="nc" id="L1133">            out.d = 1;</span>
          }
<span class="nc" id="L1135">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1136">          break;</span>
        case DCH_WW:
        case DCH_IW:
<span class="nc" id="L1139">          value.set(out.ww);</span>
<span class="nc" id="L1140">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1141">          out.ww = value.get();</span>
<span class="nc" id="L1142">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1143">          break;</span>
        case DCH_Q:
          /*
           * We ignore 'Q' when converting to date because it is unclear
           * which date in the quarter to use, and some people specify
           * both quarter and month, so if it was honored it might
           * conflict with the supplied month. That is also why we don't
           * throw an error.
           *
           * We still parse the source string for an integer, but it
           * isn't stored anywhere in 'out'.
           */
<span class="nc" id="L1155">          charIdx += from_char_parse_int(null, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1156">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1157">          break;</span>
        case DCH_CC:
<span class="nc" id="L1159">          value.set(out.cc);</span>
<span class="nc" id="L1160">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1161">          out.cc = value.get();</span>
<span class="nc" id="L1162">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1163">          break;</span>
        case DCH_Y_YYY: {
<span class="nc" id="L1165">            int commaIndex = dateText.indexOf(&quot;,&quot;, charIdx);</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">            if (commaIndex &lt;= 0) {</span>
<span class="nc" id="L1167">              throw new IllegalArgumentException(&quot;invalid input string for \&quot;Y,YYY\&quot;&quot;);</span>
            }
<span class="nc" id="L1169">            int millenia = Integer.parseInt(dateText.substring(charIdx, commaIndex));</span>
<span class="nc" id="L1170">            int years = Integer.parseInt(dateText.substring(commaIndex + 1, commaIndex + 1 + 3));</span>
<span class="nc" id="L1171">            years += (millenia * 1000);</span>
<span class="nc" id="L1172">            assertOutValue(out.year, years, node);</span>
<span class="nc" id="L1173">            out.year = years;</span>
<span class="nc" id="L1174">            out.yysz = 4;</span>
<span class="nc" id="L1175">            charIdx += strdigits_len(dateText, charIdx) + 4 + SKIP_THth(node.suffix);</span>
          }
<span class="nc" id="L1177">          break;</span>
        case DCH_YYYY:
        case DCH_IYYY:
<span class="nc" id="L1180">          value.set(out.year);</span>
<span class="nc" id="L1181">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1182">          out.year = value.get();</span>
<span class="nc" id="L1183">          out.yysz = 4;</span>
<span class="nc" id="L1184">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1185">          break;</span>
        case DCH_YYY:
        case DCH_IYY: {
<span class="nc" id="L1188">            int retVal = from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1189">            charIdx += retVal;</span>
<span class="nc" id="L1190">            out.year = value.get();</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">            if (retVal &lt; 4) {</span>
<span class="nc" id="L1192">              out.year = adjust_partial_year_to_2020(out.year);</span>
            }
<span class="nc" id="L1194">            out.yysz = 3;</span>
<span class="nc" id="L1195">            charIdx += SKIP_THth(node.suffix);</span>
            }
<span class="nc" id="L1197">          break;</span>
        case DCH_YY:
        case DCH_IY: {
<span class="nc" id="L1200">            value.set(out.year);</span>
<span class="nc" id="L1201">            int retVal = from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1202">            charIdx += retVal;</span>
<span class="nc" id="L1203">            out.year = value.get();</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">            if (retVal &lt; 4) {</span>
<span class="nc" id="L1205">              out.year = adjust_partial_year_to_2020(out.year);</span>
            }
<span class="nc" id="L1207">            out.yysz = 2;</span>
<span class="nc" id="L1208">            charIdx += SKIP_THth(node.suffix);</span>
          }
<span class="nc" id="L1210">          break;</span>
        case DCH_Y:
        case DCH_I:
<span class="nc" id="L1213">          value.set(out.year);</span>
<span class="nc" id="L1214">          int retVal = from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1215">          charIdx += retVal;</span>
<span class="nc" id="L1216">          out.year = value.get();</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">          if (retVal &lt; 4) {</span>
<span class="nc" id="L1218">            out.year = adjust_partial_year_to_2020(out.year);</span>
          }
<span class="nc" id="L1220">          out.yysz = 1;</span>
<span class="nc" id="L1221">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1222">          break;</span>
        case DCH_RM:
<span class="nc" id="L1224">          value.set(out.mm);</span>
<span class="nc" id="L1225">          charIdx += from_char_seq_search(value, dateText, charIdx, rm_months_upper, ALL_UPPER, MAX_RM_LEN, node);</span>
<span class="nc" id="L1226">          assertOutValue(out.mm, MONTHS_PER_YEAR - value.get(), node);</span>
<span class="nc" id="L1227">          out.mm = MONTHS_PER_YEAR - value.get();</span>
<span class="nc" id="L1228">          break;</span>
        case DCH_rm:
<span class="nc" id="L1230">          value.set(out.mm);</span>
<span class="nc" id="L1231">          charIdx += from_char_seq_search(value, dateText, charIdx, rm_months_lower, ALL_LOWER, MAX_RM_LEN, node);</span>
<span class="nc" id="L1232">          assertOutValue(out.mm, MONTHS_PER_YEAR - value.get(), node);</span>
<span class="nc" id="L1233">          out.mm = MONTHS_PER_YEAR - value.get();</span>
<span class="nc" id="L1234">          break;</span>
        case DCH_W:
<span class="nc" id="L1236">          value.set(out.w);</span>
<span class="nc" id="L1237">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1238">          out.w = value.get();</span>
<span class="nc" id="L1239">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1240">          break;</span>
        case DCH_J:
<span class="nc" id="L1242">          value.set(out.j);</span>
<span class="nc" id="L1243">          charIdx += from_char_parse_int(value, dateText, charIdx, nodes, nodeIdx);</span>
<span class="nc" id="L1244">          out.j = value.get();</span>
<span class="nc" id="L1245">          charIdx += SKIP_THth(node.suffix);</span>
<span class="nc" id="L1246">          break;</span>
        default:
          break;
      }
    }
<span class="nc" id="L1251">  }</span>

  static KeySuffix suff_search(char[] chars, int startIdx, int type) {
<span class="fc bfc" id="L1254" title="All 2 branches covered.">    for (KeySuffix eachSuffix: DCH_suff) {</span>
<span class="fc bfc" id="L1255" title="All 2 branches covered.">      if (eachSuffix.type != type) {</span>
<span class="fc" id="L1256">        continue;</span>
      }

<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">      if (strncmp(chars, startIdx, eachSuffix.name, eachSuffix.len)) {</span>
<span class="nc" id="L1260">        return eachSuffix;</span>
      }
    }
<span class="fc" id="L1263">    return null;</span>
  }

  /**
   * Fast sequential search, use index for data selection which
   * go to seq. cycle (it is very fast for unwanted strings)
   * (can't be used binary search in format parsing)
   * @param chars
   * @param startIdx
   * @return
   */
  static KeyWord index_seq_search(char[] chars, int startIdx) {
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">    if (KeyWord_INDEX_FILTER(chars[startIdx]) == 0) {</span>
<span class="nc" id="L1276">      return null;</span>
    }

<span class="fc" id="L1279">    Integer pos = DCH_index.get(chars[startIdx]);</span>

<span class="fc bfc" id="L1281" title="All 2 branches covered.">    if (pos != null) {</span>
<span class="fc" id="L1282">      KeyWord keyword = DCH_keywords[pos];</span>
      do {
<span class="fc bfc" id="L1284" title="All 2 branches covered.">        if (strncmp(chars, startIdx, keyword.name, keyword.len)) {</span>
<span class="fc" id="L1285">          return keyword;</span>
        }
<span class="fc" id="L1287">        pos++;</span>
<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">        if (pos &gt;=  DCH_keywords.length) {</span>
<span class="nc" id="L1289">          return null;</span>
        }
<span class="fc" id="L1291">        keyword = DCH_keywords[pos];</span>
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">      } while (chars[startIdx] == keyword.name.charAt(0));</span>
    }
<span class="fc" id="L1294">    return null;</span>
  }

  static boolean strncmp(char[] chars, int startIdx, String str, int len) {
<span class="fc bfc" id="L1298" title="All 2 branches covered.">    if (chars.length - startIdx &lt; len) {</span>
<span class="fc" id="L1299">      return false;</span>
    }

<span class="fc" id="L1302">    int index = startIdx;</span>
<span class="fc bfc" id="L1303" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++, index++) {</span>
<span class="fc bfc" id="L1304" title="All 2 branches covered.">      if (chars[index] != str.charAt(i)) {</span>
<span class="fc" id="L1305">        return false;</span>
      }
    }

<span class="fc" id="L1309">    return true;</span>
  }

  static int KeyWord_INDEX_FILTER(char c)	{
<span class="pc bpc" id="L1313" title="2 of 4 branches missed.">    return ((c) &lt;= ' ' || (c) &gt;= '~' ? 0 : 1);</span>
  }

  /**
   * Set the date mode of a from-char conversion.
   *
   * Puke if the date mode has already been set, and the caller attempts to set
   * it to a conflicting mode.
   * @param tmfc
   * @param mode
   */
  static void from_char_set_mode(TmFromChar tmfc, FromCharDateMode mode) {
<span class="pc bpc" id="L1325" title="1 of 2 branches missed.">    if (mode != FromCharDateMode.FROM_CHAR_DATE_NONE) {</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">      if (tmfc.mode == FromCharDateMode.FROM_CHAR_DATE_NONE) {</span>
<span class="nc" id="L1327">        tmfc.mode = mode;</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">      } else if (tmfc.mode != mode) {</span>
<span class="nc" id="L1329">        throw new IllegalArgumentException(&quot;invalid combination of date conventions: &quot; +</span>
                &quot;Do not mix Gregorian and ISO week date &quot; +
                &quot;conventions in a formatting template.&quot;);
      }
    }
<span class="fc" id="L1334">  }</span>

  /**
   * Perform a sequential search in 'array' for text matching the first 'max'
   * characters of the source string.
   *
   * If a match is found, copy the array index of the match into the integer
   * pointed to by 'dest', advance 'src' to the end of the part of the string
   * which matched, and return the number of characters consumed.
   *
   * If the string doesn't match, throw an error.
   * @param dest
   * @param src
   * @param charIdx
   * @param array
   * @param type
   * @param max
   * @param node
   * @return
   */
  static int from_char_seq_search(AtomicInteger dest, String src, int charIdx, String[] array, int type, int max,
                       FormatNode node) {
<span class="nc" id="L1356">    AtomicInteger len = new AtomicInteger(0);</span>

<span class="nc" id="L1358">    dest.set(seq_search(src, charIdx, array, type, max, len));</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">    if (len.get() &lt;= 0) {</span>
      String copy;
<span class="nc bnc" id="L1361" title="All 2 branches missed.">      if (charIdx + node.key.len &gt;= src.length()) {</span>
<span class="nc" id="L1362">        copy = src.substring(charIdx, charIdx + node.key.len);</span>
      } else {
<span class="nc" id="L1364">        copy = src.substring(charIdx);</span>
      }
<span class="nc" id="L1366">      throw new IllegalArgumentException(&quot;Invalid value \&quot;&quot; + copy + &quot;\&quot; for \&quot;&quot; + node.key.name + &quot;\&quot;. &quot; +</span>
          &quot;The given value did not match any of the allowed values for this field.&quot;);
    }
<span class="nc" id="L1369">    return len.get();</span>
  }

  /**
   * Sequential search with to upper/lower conversion
   * @param name
   * @param charIdx
   * @param array
   * @param type
   * @param max
   * @param len
   * @return
   */
  static int seq_search(String name, int charIdx, String[] array, int type, int max, AtomicInteger len) {
<span class="nc bnc" id="L1383" title="All 4 branches missed.">    if (name == null || name.length() &lt;= charIdx) {</span>
<span class="nc" id="L1384">      return -1;</span>
    }

<span class="nc" id="L1387">    char[] nameChars = name.toCharArray();</span>
<span class="nc" id="L1388">    char nameChar = nameChars[charIdx];</span>

	  /* set first char */
<span class="nc bnc" id="L1391" title="All 4 branches missed.">    if (type == ONE_UPPER || type == ALL_UPPER) {</span>
<span class="nc" id="L1392">      nameChar = Character.toUpperCase(nameChar);</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">    } else if (type == ALL_LOWER) {</span>
<span class="nc" id="L1394">      nameChar = Character.toLowerCase(nameChar);</span>
    }

<span class="nc" id="L1397">    int arrayIndex = 0;</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">    for (int last = 0; array[arrayIndex] != null; arrayIndex++) {</span>
<span class="nc" id="L1399">      String arrayStr = array[arrayIndex];</span>
		  /* comperate first chars */
<span class="nc bnc" id="L1401" title="All 2 branches missed.">      if (nameChar != arrayStr.charAt(0)) {</span>
<span class="nc" id="L1402">        continue;</span>
      }
<span class="nc" id="L1404">      int arrayStrLen = arrayStr.length();</span>
<span class="nc" id="L1405">      int arrayCharIdx = 1;</span>
<span class="nc" id="L1406">      int nameCharIdx = charIdx + 1;</span>

<span class="nc" id="L1408">      for (int idx = 1; ; nameCharIdx++, arrayCharIdx++, idx++) {</span>
			  // search fragment (max) only
<span class="nc bnc" id="L1410" title="All 4 branches missed.">        if (max != 0 &amp;&amp; idx == max) {</span>
<span class="nc" id="L1411">          len.set(idx + 1);   // '\0'</span>
<span class="nc" id="L1412">          return arrayIndex;</span>
        }
			  // full size
<span class="nc bnc" id="L1415" title="All 2 branches missed.">        if (arrayCharIdx == arrayStrLen - 1) {</span>
<span class="nc" id="L1416">          len.set(idx + 1);   // '\0'</span>
<span class="nc" id="L1417">          return arrayIndex;</span>
        }
        // Not found in array 'a'
<span class="nc bnc" id="L1420" title="All 2 branches missed.">        if (nameCharIdx == nameChars.length - 1) {</span>
<span class="nc" id="L1421">          break;</span>
        }
        /*
         * Convert (but convert new chars only)
         */
<span class="nc" id="L1426">        nameChar = nameChars[nameCharIdx];</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">        if (idx &gt; last) {</span>
<span class="nc bnc" id="L1428" title="All 4 branches missed.">          if (type == ONE_UPPER || type == ALL_LOWER) {</span>
<span class="nc" id="L1429">            nameChar = Character.toLowerCase(nameChar);</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">          } else if (type == ALL_UPPER) {</span>
<span class="nc" id="L1431">            nameChar = Character.toUpperCase(nameChar);</span>
          }
<span class="nc" id="L1433">          last = idx;</span>
        }
<span class="nc bnc" id="L1435" title="All 2 branches missed.">        if (nameChar != arrayStr.charAt(arrayCharIdx)){</span>
<span class="nc" id="L1436">          break;</span>
        }
      }
    }

<span class="nc" id="L1441">    return -1;</span>
  }

  /**
   * Read a single integer from the source string, into the int pointed to by
   * 'dest'. If 'dest' is NULL, the result is discarded.
   *
   * In fixed-width mode (the node does not have the FM suffix), consume at most
   * 'len' characters.  However, any leading whitespace isn't counted in 'len'.
   *
   * We use strtol() to recover the integer value from the source string, in
   * accordance with the given FormatNode.
   *
   * If the conversion completes successfully, src will have been advanced to
   * point at the character immediately following the last character used in the
   * conversion.
   *
   * Return the number of characters consumed.
   *
   * Note that from_char_parse_int() provides a more convenient wrapper where
   * the length of the field is the same as the length of the format keyword (as
   * with DD and MI).
   * @param dest
   * @param src
   * @param charIdx
   * @param len
   * @param nodes
   * @param nodeIndex
   * @return
   */
  static int from_char_parse_int_len(AtomicInteger dest, String src, int charIdx, int len, FormatNode[] nodes, int nodeIndex) {
    long result;
<span class="fc" id="L1473">    int	 initCharIdx = charIdx;</span>
<span class="fc" id="L1474">    StringBuilder tempSb = new StringBuilder();</span>

    /*
     * Skip any whitespace before parsing the integer.
     */
<span class="fc" id="L1479">    charIdx = strspace_len(src, charIdx);</span>

<span class="pc bpc" id="L1481" title="1 of 2 branches missed.">    int used = src.length() &lt;= charIdx + len ? src.length() - (charIdx + len) : len;</span>
<span class="pc bpc" id="L1482" title="1 of 2 branches missed.">    if (used &lt;= 0) {</span>
<span class="nc" id="L1483">      used = src.length() - charIdx;</span>
    }
<span class="fc" id="L1485">    String copy = src.substring(charIdx, charIdx + used);</span>

<span class="pc bpc" id="L1487" title="2 of 4 branches missed.">    if (S_FM(nodes[nodeIndex].suffix) != 0 || is_next_separator(nodes, nodeIndex)) {</span>
		/*
		 * This node is in Fill Mode, or the next node is known to be a
		 * non-digit value, so we just slurp as many characters as we can get.
		 */
<span class="fc" id="L1492">      result = DateTimeUtil.strtol(src, charIdx, tempSb);</span>
<span class="fc" id="L1493">      charIdx = src.length() - tempSb.length();</span>
    } else {

      /*
       * We need to pull exactly the number of characters given in 'len' out
       * of the string, and convert those.
       */
<span class="nc bnc" id="L1500" title="All 2 branches missed.">      if (used &lt; len) {</span>
<span class="nc" id="L1501">        throw new IllegalArgumentException(&quot;source string too short for \&quot;&quot; + nodes[nodeIndex].key.name + &quot;\&quot; + formatting field&quot;);</span>
      }
<span class="nc" id="L1503">      result = DateTimeUtil.strtol(copy, 0, tempSb);</span>
<span class="nc" id="L1504">      used = copy.length() - tempSb.length();</span>

<span class="nc bnc" id="L1506" title="All 4 branches missed.">      if (used &gt; 0 &amp;&amp; used &lt; len) {</span>
<span class="nc" id="L1507">        throw new IllegalArgumentException(&quot;invalid value \&quot;&quot; + copy + &quot;\&quot; for \&quot;&quot; + nodes[nodeIndex].key.name + &quot;\&quot;.&quot; +</span>
            &quot;Field requires &quot; + len + &quot; characters, but only &quot; + used);
      }
<span class="nc" id="L1510">      charIdx += used;</span>
    }

<span class="pc bpc" id="L1513" title="1 of 2 branches missed.">    if (charIdx == initCharIdx) {</span>
<span class="fc" id="L1514">      throw new IllegalArgumentException(&quot;invalid value \&quot;&quot; + copy + &quot;\&quot; for \&quot;&quot; + nodes[nodeIndex].key.name + &quot;\&quot;.&quot; +</span>
          &quot;Value must be an integer.&quot;);
    }
<span class="nc bnc" id="L1517" title="All 4 branches missed.">    if (result &lt; Integer.MIN_VALUE || result &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L1518">      throw new IllegalArgumentException(&quot;value for \&quot;&quot; + nodes[nodeIndex].key.name + &quot;\&quot;&quot; +</span>
          &quot; in source string is out of range.&quot; +
          &quot;Value must be in the range &quot; + Integer.MIN_VALUE + &quot; to &quot; + Integer.MAX_VALUE + &quot;.&quot;);
    }
<span class="nc bnc" id="L1522" title="All 2 branches missed.">    if (dest != null) {</span>
<span class="nc" id="L1523">      assertOutValue(dest.get(), (int)result, nodes[nodeIndex]);</span>
<span class="nc" id="L1524">      dest.set((int)result);</span>
    }
<span class="nc" id="L1526">    return charIdx - initCharIdx;</span>
  }

  /**
   * Call from_char_parse_int_len(), using the length of the format keyword as
   * the expected length of the field.
   *
   * Don't call this function if the field differs in length from the format
   * keyword (as with HH24; the keyword length is 4, but the field length is 2).
   * In such cases, call from_char_parse_int_len() instead to specify the
   * required length explicitly.
   * @param dest
   * @param src
   * @param charIdx
   * @param nodes
   * @param nodeIdx
   * @return
   */
  static int from_char_parse_int(AtomicInteger dest, String src, int charIdx, FormatNode[] nodes, int nodeIdx) {
<span class="nc" id="L1545">    return from_char_parse_int_len(dest, src, charIdx, nodes[nodeIdx].key.len, nodes, nodeIdx);</span>
  }

  static int strspace_len(String str, int charIdx) {
<span class="fc" id="L1549">    int len = str.length();</span>
<span class="pc bpc" id="L1550" title="2 of 4 branches missed.">    while (charIdx &lt; len &amp;&amp; Character.isSpaceChar(str.charAt(charIdx))) {</span>
<span class="nc" id="L1551">      charIdx++;</span>
    }
<span class="fc" id="L1553">    return charIdx;</span>
  }

  static int strdigits_len(String str, int charIdx) {
<span class="nc" id="L1557">    int len = strspace_len(str, charIdx);</span>
<span class="nc" id="L1558">    int index = charIdx + len;</span>

<span class="nc" id="L1560">    int strLen = str.length();</span>

<span class="nc bnc" id="L1562" title="All 6 branches missed.">    while (index &lt; strLen &amp;&amp; Character.isDigit(str.charAt(index)) &amp;&amp; len &lt;= DCH_MAX_ITEM_SIZ) {</span>
<span class="nc" id="L1563">      len++;</span>
<span class="nc" id="L1564">      index++;</span>
    }
<span class="nc" id="L1566">    return len;</span>
  }

  static void assertOutValue(int dest, int value, FormatNode node) {
<span class="nc bnc" id="L1570" title="All 4 branches missed.">    if (dest != 0 &amp;&amp; dest != value) {</span>
<span class="nc" id="L1571">      throw new IllegalArgumentException(</span>
          &quot;conflicting values for \&quot;&quot; + node.key.name + &quot;\&quot; field in formatting string,&quot; +
          &quot;This value contradicts a previous setting for the same field type(&quot; + dest + &quot;,&quot; + value + &quot;)&quot;);
    }
<span class="nc" id="L1575">  }</span>

  /**
   * Return true if next format picture is not digit value
   * @param nodes
   * @param nodeIndex
   * @return
   */
  static boolean is_next_separator(FormatNode[] nodes, int nodeIndex) {
<span class="fc" id="L1584">    int index = nodeIndex;</span>
<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">    if (nodes[index].type == NODE_TYPE_END) {</span>
<span class="nc" id="L1586">      return false;</span>
    }

<span class="pc bpc" id="L1589" title="2 of 4 branches missed.">    if (nodes[index].type == NODE_TYPE_ACTION &amp;&amp; S_THth(nodes[index].suffix) != 0) {</span>
<span class="nc" id="L1590">      return true;</span>
    }

    /*
     * Next node
     */
<span class="fc" id="L1596">    index++;</span>

	/* end of format string is treated like a non-digit separator */
<span class="pc bpc" id="L1599" title="1 of 2 branches missed.">    if (nodes[index].type == NODE_TYPE_END) {</span>
<span class="nc" id="L1600">      return true;</span>
    }

<span class="pc bpc" id="L1603" title="1 of 2 branches missed.">    if (nodes[index].type == NODE_TYPE_ACTION) {</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">      return nodes[index].key.is_digit ? false : true;</span>
<span class="pc bpc" id="L1605" title="1 of 2 branches missed.">    } else if (Character.isDigit(nodes[index].character)) {</span>
<span class="nc" id="L1606">      return false;</span>
    }

<span class="fc" id="L1609">    return true;				/* some non-digit input (separator) */</span>
  }

  /**
   * Adjust all dates toward 2020; this is effectively what happens when we
   * assume '70' is 1970 and '69' is 2069.
   * @param year
   * @return
   */
  static int adjust_partial_year_to_2020(int year) {
<span class="nc bnc" id="L1619" title="All 2 branches missed.">    if (year &lt; 70) {</span>
      /* Force 0-69 into the 2000's */
<span class="nc" id="L1621">      return year + 2000;</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">    } else if (year &lt; 100) {</span>
      /* Force 70-99 into the 1900's */
<span class="nc" id="L1624">      return year + 1900;</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">    } else if (year &lt; 520) {</span>
      /* Force 100-519 into the 2000's */
<span class="nc" id="L1627">      return year + 2000;</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">    } else if (year &lt; 1000) {</span>
      /* Force 520-999 into the 1000's */
<span class="nc" id="L1630">      return year + 1000;</span>
    } else {
<span class="nc" id="L1632">      return year;</span>
    }
  }

  /**
   * Converts TimeMeta to a string using given the format pattern text.
   * @param tm
   * @param formatText
   * @return
   */
  public static String to_char(TimeMeta tm, String formatText) {
<span class="nc" id="L1643">    int fmt_len = formatText.length();</span>

<span class="nc" id="L1645">    StringBuilder out = new StringBuilder();</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">    if (fmt_len &gt; 0) {</span>
      FormatNode[] formatNodes;

<span class="nc" id="L1649">      synchronized(formatNodeCache) {</span>
<span class="nc" id="L1650">        formatNodes = formatNodeCache.get(formatText);</span>
<span class="nc" id="L1651">      }</span>

<span class="nc bnc" id="L1653" title="All 2 branches missed.">      if (formatNodes == null) {</span>
<span class="nc" id="L1654">        formatNodes = new FormatNode[fmt_len + 1];</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">        for (int i = 0; i &lt; formatNodes.length; i++) {</span>
<span class="nc" id="L1656">          formatNodes[i] = new FormatNode();</span>
        }
<span class="nc" id="L1658">        parseFormat(formatNodes, formatText, FORMAT_TYPE.DCH_TYPE);</span>
<span class="nc" id="L1659">        formatNodes[fmt_len].type = NODE_TYPE_END;	/* Paranoia? */</span>

<span class="nc" id="L1661">        synchronized(formatNodeCache) {</span>
<span class="nc" id="L1662">          formatNodeCache.put(formatText, formatNodes);</span>
<span class="nc" id="L1663">        }</span>
      }
<span class="nc" id="L1665">      DCH_to_char(formatNodes, false, tm, out);</span>
<span class="nc" id="L1666">      return out.toString();</span>
    } else {
<span class="nc" id="L1668">      throw new IllegalArgumentException(&quot;No format text.&quot;);</span>
    }
  }
  
<span class="fc" id="L1672">  private static final char[][] zeroStrings = {{}, {'0'}, {'0', '0'}, {'0', '0', '0'}, </span>
    {'0', '0', '0', '0'}, {'0', '0', '0', '0', '0'}, {'0', '0', '0', '0', '0', '0'}};
  
  /**
   * Format integer value to strings.
   * @param value - the value to format a string
   * @param size - minimal width of string
   */
  private static String formatInteger(int value, int size) {
    char[] targetArray, tempArray;
<span class="nc bnc" id="L1682" title="All 2 branches missed.">    final boolean isPositive = value&gt;=0;</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">    final int tempValue = isPositive?value:-value;</span>
    int targetArraySize;
    
<span class="nc" id="L1686">    tempArray = Integer.toString(tempValue).toCharArray();</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">    targetArraySize = Math.max(tempArray.length, size + (isPositive?0:1));</span>
<span class="nc" id="L1688">    targetArray = new char[targetArraySize];</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">    if (size &gt; tempArray.length) {</span>
<span class="nc" id="L1690">      System.arraycopy(zeroStrings[size], 0, targetArray, (targetArraySize-size), size);</span>
    }
<span class="nc" id="L1692">    System.arraycopy(tempArray, 0, targetArray, (targetArraySize-tempArray.length), tempArray.length);</span>
    
<span class="nc bnc" id="L1694" title="All 2 branches missed.">    if (!isPositive) {</span>
<span class="nc" id="L1695">      targetArray[0] = '-';</span>
    }
    
<span class="nc" id="L1698">    return new String(targetArray);</span>
  }
  
  /**
   * Format string value
   * @param value - the value to format
   * @param width - minimal width of string
   * @return
   */
  private static String formatString(String value, int width) {
    char[] targetArray, tempArray;
<span class="nc bnc" id="L1709" title="All 2 branches missed.">    final boolean isLeftJustified = width&lt;0;</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">    final int minimalWidth = isLeftJustified?-width:width;</span>
<span class="nc" id="L1711">    String result = value;</span>
    int targetArraySize;
    
<span class="nc bnc" id="L1714" title="All 4 branches missed.">    if (minimalWidth &gt; 0 &amp;&amp; value != null) {</span>
<span class="nc" id="L1715">      tempArray = value.toCharArray();</span>
<span class="nc" id="L1716">      targetArraySize = Math.max(tempArray.length, minimalWidth);</span>
<span class="nc" id="L1717">      targetArray = new char[targetArraySize];</span>
<span class="nc" id="L1718">      Arrays.fill(targetArray, ' ');</span>
<span class="nc bnc" id="L1719" title="All 2 branches missed.">      System.arraycopy(tempArray, 0, targetArray, </span>
          isLeftJustified?0:(targetArraySize-tempArray.length), tempArray.length);
<span class="nc" id="L1721">      result = new String(targetArray);</span>
    }
    
<span class="nc" id="L1724">    return result;</span>
  }

  /**
   * Process a TmToChar struct as denoted by a list of FormatNodes.
   * The formatted data is written to the string pointed to by 'out'.
   * @param nodes
   * @param isInterval
   * @param tm
   * @param out
   */
  private static void DCH_to_char(FormatNode[] nodes, boolean isInterval, TimeMeta tm, StringBuilder out) {
    int i;
<span class="nc bnc" id="L1737" title="All 2 branches missed.">    for (FormatNode node: nodes) {</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">      if (node.type == NODE_TYPE_END) {</span>
<span class="nc" id="L1739">        break;</span>
      }
<span class="nc bnc" id="L1741" title="All 2 branches missed.">      if (node.type != NODE_TYPE_ACTION) {</span>
<span class="nc" id="L1742">        out.append(node.character);</span>
<span class="nc" id="L1743">        continue;</span>
      }

<span class="nc bnc" id="L1746" title="All 47 branches missed.">      switch (node.key.idType) {</span>
        case DCH_A_M:
        case DCH_P_M:
<span class="nc bnc" id="L1749" title="All 2 branches missed.">          out.append((tm.hours % HOURS_PER_DAY &gt;= HOURS_PER_DAY / 2) ? P_M_STR : A_M_STR);</span>
<span class="nc" id="L1750">          break;</span>
        case DCH_AM:
        case DCH_PM:
<span class="nc bnc" id="L1753" title="All 2 branches missed.">          out.append((tm.hours % HOURS_PER_DAY &gt;= HOURS_PER_DAY / 2) ? PM_STR : AM_STR);</span>
<span class="nc" id="L1754">          break;</span>
        case DCH_a_m:
        case DCH_p_m:
<span class="nc bnc" id="L1757" title="All 2 branches missed.">          out.append((tm.hours % HOURS_PER_DAY &gt;= HOURS_PER_DAY / 2) ? p_m_STR : a_m_STR);</span>
<span class="nc" id="L1758">          break;</span>
        case DCH_am:
        case DCH_pm:
<span class="nc bnc" id="L1761" title="All 2 branches missed.">          out.append((tm.hours % HOURS_PER_DAY &gt;= HOURS_PER_DAY / 2) ? pm_STR : am_STR);</span>
<span class="nc" id="L1762">          break;</span>
        case DCH_HH:
        case DCH_HH12: {
          /*
           * display time as shown on a 12-hour clock, even for
           * intervals
           */
<span class="nc bnc" id="L1769" title="All 2 branches missed.">        out.append(formatInteger(tm.hours % (HOURS_PER_DAY / 2) == 0 ? HOURS_PER_DAY / 2 : tm.hours</span>
            % (HOURS_PER_DAY / 2), 
<span class="nc bnc" id="L1771" title="All 2 branches missed.">            S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1773">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_HH24: {
<span class="nc bnc" id="L1778" title="All 2 branches missed.">          out.append(formatInteger(tm.hours, S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1780">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_MI: {
<span class="nc bnc" id="L1785" title="All 2 branches missed.">          out.append(formatInteger(tm.minutes, S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L1786" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1787">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_SS: {
<span class="nc bnc" id="L1792" title="All 2 branches missed.">          out.append(formatInteger(tm.secs, S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1794">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_MS:		/* millisecond */
<span class="nc" id="L1799">          out.append(formatInteger((int)(tm.fsecs/1000.0), 3));</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1801">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_US:		/* microsecond */
<span class="nc" id="L1805">          out.append(formatInteger((int) tm.fsecs, 6));</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1807">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_SSSS:
<span class="nc" id="L1811">          out.append(formatInteger((tm.hours * DateTimeConstants.SECS_PER_HOUR +</span>
              tm.minutes * DateTimeConstants.SECS_PER_MINUTE + tm.secs), 0));
<span class="nc bnc" id="L1813" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1814">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_tz:
<span class="nc" id="L1818">          invalidForInterval(isInterval, node);</span>
          //TODO
<span class="nc" id="L1820">          break;</span>
        case DCH_A_D:
        case DCH_B_C:
<span class="nc" id="L1823">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">          out.append((tm.years &lt;= 0 ? B_C_STR : A_D_STR));</span>
<span class="nc" id="L1825">          break;</span>
        case DCH_AD:
        case DCH_BC:
<span class="nc" id="L1828">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">          out.append((tm.years &lt;= 0 ? BC_STR : AD_STR));</span>
<span class="nc" id="L1830">          break;</span>
        case DCH_a_d:
        case DCH_b_c:
<span class="nc" id="L1833">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">          out.append((tm.years &lt;= 0 ? b_c_STR : a_d_STR));</span>
<span class="nc" id="L1835">          break;</span>
        case DCH_ad:
        case DCH_bc:
<span class="nc" id="L1838">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1839" title="All 2 branches missed.">          out.append((tm.years &lt;= 0 ? bc_STR : ad_STR));</span>
<span class="nc" id="L1840">          break;</span>
        case DCH_MONTH:
<span class="nc" id="L1842">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">          if (tm.monthOfYear == 0) {</span>
<span class="nc" id="L1844">            break;</span>
          }
<span class="nc bnc" id="L1846" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1847">            out.append(months_full[tm.monthOfYear - 1].toUpperCase());</span>
          } else {
<span class="nc" id="L1849">            out.append(formatString(months_full[tm.monthOfYear - 1].toUpperCase(), </span>
<span class="nc bnc" id="L1850" title="All 2 branches missed.">                S_FM(node.suffix)!=0?0:-9));</span>
          }
<span class="nc" id="L1852">          break;</span>
        case DCH_Month:
<span class="nc" id="L1854">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">          if (tm.monthOfYear == 0) {</span>
<span class="nc" id="L1856">            break;</span>
          }
<span class="nc bnc" id="L1858" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1859">            out.append(months_full[tm.monthOfYear - 1]);</span>
          } else {
<span class="nc" id="L1861">            out.append(formatString(months_full[tm.monthOfYear - 1], </span>
<span class="nc bnc" id="L1862" title="All 2 branches missed.">                S_FM(node.suffix)!=0?0:-9));</span>
          }
<span class="nc" id="L1864">          break;</span>
        case DCH_month:
<span class="nc" id="L1866">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">          if (tm.monthOfYear == 0) {</span>
<span class="nc" id="L1868">            break;</span>
          }
<span class="nc bnc" id="L1870" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1871">            out.append(months_full[tm.monthOfYear - 1].toLowerCase());</span>
          } else {
<span class="nc" id="L1873">            out.append(formatString(months_full[tm.monthOfYear - 1].toLowerCase(), </span>
<span class="nc bnc" id="L1874" title="All 2 branches missed.">                S_FM(node.suffix)!=0?0:-9));</span>
          }
<span class="nc" id="L1876">          break;</span>
        case DCH_MON:
<span class="nc" id="L1878">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">          if (tm.monthOfYear == 0) {</span>
<span class="nc" id="L1880">            break;</span>
          }
<span class="nc bnc" id="L1882" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1883">            out.append(months_short[tm.monthOfYear - 1].toUpperCase());</span>
          } else {
<span class="nc" id="L1885">            out.append(months_short[tm.monthOfYear - 1].toUpperCase());</span>
          }
<span class="nc" id="L1887">          break;</span>
        case DCH_Mon:
<span class="nc" id="L1889">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">          if (tm.monthOfYear == 0) {</span>
<span class="nc" id="L1891">            break;</span>
          }
<span class="nc bnc" id="L1893" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1894">            out.append(months_short[tm.monthOfYear - 1]);</span>
          } else {
<span class="nc" id="L1896">            out.append(months_short[tm.monthOfYear - 1]);</span>
          }
<span class="nc" id="L1898">          break;</span>
        case DCH_mon:
<span class="nc" id="L1900">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">          if (tm.monthOfYear == 0)</span>
<span class="nc" id="L1902">            break;</span>
<span class="nc bnc" id="L1903" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1904">            out.append(months_short[tm.monthOfYear - 1].toLowerCase());</span>
          } else {
<span class="nc" id="L1906">            out.append(months_short[tm.monthOfYear - 1].toLowerCase());</span>
          }
<span class="nc" id="L1908">          break;</span>
        case DCH_MM: {
<span class="nc bnc" id="L1910" title="All 2 branches missed.">          out.append(formatInteger(tm.monthOfYear, S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L1911" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1912">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_DAY: {
<span class="nc" id="L1917">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1919">            out.append(days_full[tm.getDayOfWeek()].toUpperCase());</span>
          } else {
<span class="nc" id="L1921">            out.append(formatString(days_full[tm.getDayOfWeek()].toUpperCase(), </span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">                S_FM(node.suffix)!=0?0:-9));</span>
          }
<span class="nc" id="L1924">          break;</span>
        }
        case DCH_Day:
<span class="nc" id="L1927">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1928" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1929">            out.append(days_full[tm.getDayOfWeek()]);</span>
          } else {
<span class="nc" id="L1931">            out.append(formatString(days_full[tm.getDayOfWeek()], </span>
<span class="nc bnc" id="L1932" title="All 2 branches missed.">                S_FM(node.suffix)!=0?0:-9));</span>
          }
<span class="nc" id="L1934">          break;</span>
        case DCH_day:
<span class="nc" id="L1936">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1938">            out.append(days_full[tm.getDayOfWeek()].toLowerCase());</span>
          } else {
<span class="nc" id="L1940">            out.append(formatString(days_full[tm.getDayOfWeek()].toLowerCase(), </span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">                S_FM(node.suffix)!=0?0:-9));</span>
          }
<span class="nc" id="L1943">          break;</span>
        case DCH_DY:
<span class="nc" id="L1945">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1946" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1947">            out.append(days_short[tm.getDayOfWeek()]);</span>
          } else {
<span class="nc" id="L1949">            out.append(days_short[tm.getDayOfWeek()]);</span>
          }
<span class="nc" id="L1951">          break;</span>
        case DCH_Dy:
<span class="nc" id="L1953">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1955">            out.append(days_short[tm.getDayOfWeek()]);</span>
          } else {
<span class="nc" id="L1957">            out.append(days_short[tm.getDayOfWeek()]);</span>
          }
<span class="nc" id="L1959">          break;</span>
        case DCH_dy:
<span class="nc" id="L1961">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">          if (S_TM(node.suffix) != 0) {</span>
<span class="nc" id="L1963">            out.append(days_short[tm.getDayOfWeek()]);</span>
          } else {
<span class="nc" id="L1965">            out.append(days_short[tm.getDayOfWeek()]);</span>
          }
<span class="nc" id="L1967">          break;</span>
        case DCH_DDD:
        case DCH_IDDD: {
<span class="nc bnc" id="L1970" title="All 2 branches missed.">          out.append(formatInteger((node.key.idType == DCH_poz.DCH_DDD) ?</span>
<span class="nc" id="L1971">                  tm.getDayOfYear() : DateTimeUtil.date2isoyearday(tm.years, tm.monthOfYear, tm.dayOfMonth), </span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                  S_FM(node.suffix)!=0?0:3));</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1974">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_DD: {
<span class="nc bnc" id="L1979" title="All 2 branches missed.">          out.append(formatInteger(tm.dayOfMonth, S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1981">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_D:
<span class="nc" id="L1986">          invalidForInterval(isInterval, node);</span>
<span class="nc" id="L1987">          out.append(formatInteger(tm.getDayOfWeek()+1, 0));</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1989">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_ID:
<span class="nc" id="L1993">          invalidForInterval(isInterval, node);</span>
<span class="nc bnc" id="L1994" title="All 2 branches missed.">          out.append(formatInteger((tm.getDayOfWeek()==0)?7:tm.getDayOfWeek(), 0));</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L1996">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_WW: {
<span class="nc bnc" id="L2000" title="All 2 branches missed.">          out.append(formatInteger((tm.getDayOfYear()-1)/7+1, S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L2001" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2002">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_IW: {
<span class="nc" id="L2007">          out.append(formatInteger(DateTimeUtil.date2isoweek(tm.years, tm.monthOfYear, tm.dayOfMonth), </span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">              S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L2009" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2010">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_Q:
<span class="nc bnc" id="L2015" title="All 2 branches missed.">          if (tm.monthOfYear == 0) {</span>
<span class="nc" id="L2016">            break;</span>
          }
<span class="nc" id="L2018">          out.append(formatInteger((tm.monthOfYear-1)/3+1, 0));</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2020">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_CC: {
<span class="nc bnc" id="L2024" title="All 2 branches missed.">          if (isInterval) { /* straight calculation */</span>
<span class="nc" id="L2025">            i = tm.years / 100;</span>
          } else {
<span class="nc bnc" id="L2027" title="All 2 branches missed.">            if (tm.years &gt; 0) {</span>
						/* Century 20 == 1901 - 2000 */
<span class="nc" id="L2029">              i = (tm.years - 1) / 100 + 1;</span>
            } else {
						/* Century 6BC == 600BC - 501BC */
<span class="nc" id="L2032">              i = tm.years / 100 - 1;</span>
            }
          }
<span class="nc bnc" id="L2035" title="All 4 branches missed.">          if (i &lt;= 99 &amp;&amp; i &gt;= -99) {</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">            out.append(formatInteger(i, S_FM(node.suffix)!=0?0:2));</span>
          } else {
<span class="nc" id="L2038">            out.append(formatInteger(i, 0));</span>
          }
<span class="nc bnc" id="L2040" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2041">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_Y_YYY:
<span class="nc" id="L2046">          i = ADJUST_YEAR(tm.years, isInterval) / 1000;</span>
<span class="nc" id="L2047">          out.append(formatInteger(i, 0))</span>
<span class="nc" id="L2048">          .append(',')</span>
<span class="nc" id="L2049">          .append(formatInteger(ADJUST_YEAR(tm.years, isInterval) - (i * 1000), 3));</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2051">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_YYYY:
        case DCH_IYYY: {
<span class="nc bnc" id="L2056" title="All 2 branches missed.">          out.append(formatInteger((node.key.idType == DCH_poz.DCH_YYYY ? ADJUST_YEAR(tm.years, isInterval) :</span>
<span class="nc" id="L2057">                  ADJUST_YEAR(DateTimeUtil.date2isoyear(tm.years, tm.monthOfYear, tm.dayOfMonth), isInterval)), </span>
<span class="nc bnc" id="L2058" title="All 2 branches missed.">                  S_FM(node.suffix)!=0?0:4));</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2060">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_YYY:
        case DCH_IYY: {
<span class="nc bnc" id="L2066" title="All 2 branches missed.">          out.append(formatInteger((node.key.idType == DCH_poz.DCH_YYY ? ADJUST_YEAR(tm.years, isInterval) :</span>
<span class="nc" id="L2067">                  ADJUST_YEAR(DateTimeUtil.date2isoyear(tm.years, tm.monthOfYear, tm.dayOfMonth), isInterval)) % 1000, </span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                  S_FM(node.suffix)!=0?0:3));</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2070">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        }
        case DCH_YY:
        case DCH_IY: {
<span class="nc bnc" id="L2076" title="All 2 branches missed.">          out.append(formatInteger((node.key.idType == DCH_poz.DCH_YY ? ADJUST_YEAR(tm.years, isInterval) :</span>
<span class="nc" id="L2077">                  ADJUST_YEAR(DateTimeUtil.date2isoyear(tm.years, tm.monthOfYear, tm.dayOfMonth), isInterval)) % 100, </span>
<span class="nc bnc" id="L2078" title="All 2 branches missed.">                  S_FM(node.suffix)!=0?0:2));</span>
<span class="nc bnc" id="L2079" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0)</span>
<span class="nc" id="L2080">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          break;
        }
        case DCH_Y:
        case DCH_I:
<span class="nc bnc" id="L2085" title="All 2 branches missed.">          out.append(formatInteger((node.key.idType == DCH_poz.DCH_Y ?</span>
<span class="nc" id="L2086">                  ADJUST_YEAR(tm.years, isInterval) :</span>
<span class="nc" id="L2087">                  ADJUST_YEAR(DateTimeUtil.date2isoyear(tm.years, tm.monthOfYear, tm.dayOfMonth),</span>
                      isInterval)) % 10, 1));
<span class="nc bnc" id="L2089" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2090">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_RM: {
<span class="nc bnc" id="L2094" title="All 2 branches missed.">          if (tm.monthOfYear == 0) {</span>
<span class="nc" id="L2095">            break;</span>
          }
<span class="nc" id="L2097">          out.append(formatString(rm_months_upper[MONTHS_PER_YEAR - tm.monthOfYear],</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">              S_FM(node.suffix)!=0?0:-4));</span>
<span class="nc" id="L2099">          break;</span>
        }
        case DCH_rm: {
<span class="nc bnc" id="L2102" title="All 2 branches missed.">          if (tm.monthOfYear == 0) {</span>
<span class="nc" id="L2103">            break;</span>
          }
<span class="nc" id="L2105">          out.append(formatString(rm_months_lower[MONTHS_PER_YEAR - tm.monthOfYear],</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">              S_FM(node.suffix)!=0?0:-4));</span>
<span class="nc" id="L2107">          break;</span>
        }
        case DCH_W:
<span class="nc" id="L2110">          out.append(formatInteger((tm.dayOfMonth-1)/7+1, 0));</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2112">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        case DCH_J:
<span class="nc" id="L2116">          out.append(formatInteger(DateTimeUtil.date2j(tm.years, tm.monthOfYear, tm.dayOfMonth), 0));</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">          if (S_THth(node.suffix) != 0) {</span>
<span class="nc" id="L2118">            str_numth(out, out, S_TH_TYPE(node.suffix));</span>
          }
          break;
        default:
          break;
      }
    }
<span class="nc" id="L2125">  }</span>

  /**
   * Return ST/ND/RD/TH for simple (1..9) numbers
   * type --&gt; 0 upper, 1 lower
   * @param num
   * @param type
   * @return
   */
  static String get_th(StringBuilder num, int type) {
<span class="nc" id="L2135">    int	len = num.length();</span>
<span class="nc" id="L2136">    char last = num.charAt(len - 1);</span>

<span class="nc bnc" id="L2138" title="All 2 branches missed.">    if (!Character.isDigit(last)) {</span>
<span class="nc" id="L2139">      throw new IllegalArgumentException(&quot;\&quot;&quot; + num.toString() + &quot;\&quot; is not a number&quot;);</span>
    }

    /*
     * All &quot;teens&quot; (&lt;x&gt;1[0-9]) get 'TH/th', while &lt;x&gt;[02-9][123] still get
     * 'ST/st', 'ND/nd', 'RD/rd', respectively
     */
<span class="nc bnc" id="L2146" title="All 4 branches missed.">    if ((len &gt; 1) &amp;&amp; (num.charAt(len - 2) == '1')) {</span>
<span class="nc" id="L2147">      last = 0;</span>
    }

<span class="nc bnc" id="L2150" title="All 4 branches missed.">    switch (last) {</span>
      case '1':
<span class="nc bnc" id="L2152" title="All 2 branches missed.">        if (type == TH_UPPER)</span>
<span class="nc" id="L2153">          return numTH[0];</span>
<span class="nc" id="L2154">        return numth[0];</span>
      case '2':
<span class="nc bnc" id="L2156" title="All 2 branches missed.">        if (type == TH_UPPER)</span>
<span class="nc" id="L2157">          return numTH[1];</span>
<span class="nc" id="L2158">        return numth[1];</span>
      case '3':
<span class="nc bnc" id="L2160" title="All 2 branches missed.">        if (type == TH_UPPER)</span>
<span class="nc" id="L2161">          return numTH[2];</span>
<span class="nc" id="L2162">        return numth[2];</span>
      default:
<span class="nc bnc" id="L2164" title="All 2 branches missed.">        if (type == TH_UPPER)</span>
<span class="nc" id="L2165">          return numTH[3];</span>
<span class="nc" id="L2166">        return numth[3];</span>
    }
  }

  /**
   * Convert string-number to ordinal string-number
   * type --&gt; 0 upper, 1 lower
   * @param dest
   * @param num
   * @param type
   */
  static void str_numth(StringBuilder dest, StringBuilder num, int type) {
<span class="nc bnc" id="L2178" title="All 2 branches missed.">    if (!dest.equals(num)) {</span>
<span class="nc" id="L2179">      dest.append(num);</span>
    }
<span class="nc" id="L2181">    dest.append(get_th(num, type));</span>
<span class="nc" id="L2182">  }</span>

  private static void invalidForInterval(boolean isInterval, FormatNode node) {
<span class="nc bnc" id="L2185" title="All 2 branches missed.">    if (isInterval) {</span>
<span class="nc" id="L2186">      throw new IllegalArgumentException(&quot;\&quot;&quot; + node.key.name + &quot;\&quot; not support for interval&quot;);</span>
    }
<span class="nc" id="L2188">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>