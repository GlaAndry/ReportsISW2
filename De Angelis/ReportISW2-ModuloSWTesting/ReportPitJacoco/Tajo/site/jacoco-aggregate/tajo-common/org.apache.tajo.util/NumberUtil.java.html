<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NumberUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Apache Tajo :: Tests Coverage</a> &gt; <a href="../index.html" class="el_bundle">tajo-common</a> &gt; <a href="index.source.html" class="el_package">org.apache.tajo.util</a> &gt; <span class="el_source">NumberUtil.java</span></div><h1>NumberUtil.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.tajo.util;

import io.netty.buffer.ByteBuf;
import io.netty.util.internal.PlatformDependent;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Constructor;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;

// this is an implementation copied from LazyPrimitives in hive
<span class="nc" id="L33">public class NumberUtil {</span>

<span class="nc" id="L35">  public static final double[] powersOf10 = {	/* Table giving binary powers of 10.  Entry */</span>
      10.,		 	                              /* is 10^2^i.  Used to convert decimal */
      100.,		 	                              /* exponents into floating-point numbers. */
      1.0e4,
      1.0e8,
      1.0e16,
      1.0e32,
      1.0e64,
      1.0e128,
      1.0e256
  };
  private static final int maxExponent = 511;	/* Largest possible base 10 exponent.  Any
                                               * exponent larger than this will already
                                               * produce underflow or overflow, so there's
                                               * no need to worry about additional digits.
                                               */

  /** When we encode strings, we always specify UTF8 encoding */
  public static final String UTF8_ENCODING = &quot;UTF-8&quot;;

  /** When we encode strings, we always specify UTF8 encoding */
<span class="nc" id="L56">  public static final Charset UTF8_CHARSET = Charset.forName(UTF8_ENCODING);</span>

  /**
   * Size of boolean in bytes
   */
  public static final int SIZEOF_BOOLEAN = Byte.SIZE / Byte.SIZE;

  /**
   * Size of byte in bytes
   */
  public static final int SIZEOF_BYTE = SIZEOF_BOOLEAN;

  /**
   * Size of char in bytes
   */
  public static final int SIZEOF_CHAR = Character.SIZE / Byte.SIZE;

  /**
   * Size of double in bytes
   */
  public static final int SIZEOF_DOUBLE = Double.SIZE / Byte.SIZE;

  /**
   * Size of float in bytes
   */
  public static final int SIZEOF_FLOAT = Float.SIZE / Byte.SIZE;

  /**
   * Size of int in bytes
   */
  public static final int SIZEOF_INT = Integer.SIZE / Byte.SIZE;

  /**
   * Size of long in bytes
   */
  public static final int SIZEOF_LONG = Long.SIZE / Byte.SIZE;

  /**
   * Size of short in bytes
   */
  public static final int SIZEOF_SHORT = Short.SIZE / Byte.SIZE;

  public static long unsigned32(int n) {
<span class="nc" id="L99">    return n &amp; 0xFFFFFFFFL;</span>
  }

  public static int unsigned16(short n) {
<span class="nc" id="L103">    return n &amp; 0xFFFF;</span>
  }

  public static byte[] toAsciiBytes(Number i) {
<span class="nc" id="L107">    return BytesUtils.toASCIIBytes(String.valueOf(i).toCharArray());</span>
  }

  public static byte[] toAsciiBytes(short i) {
<span class="nc" id="L111">    return BytesUtils.toASCIIBytes(String.valueOf(i).toCharArray());</span>
  }

  public static byte[] toAsciiBytes(int i) {
<span class="nc" id="L115">    return BytesUtils.toASCIIBytes(String.valueOf(i).toCharArray());</span>
  }

  public static byte[] toAsciiBytes(long i) {
<span class="nc" id="L119">    return BytesUtils.toASCIIBytes(String.valueOf(i).toCharArray());</span>
  }

  public static byte[] toAsciiBytes(float i) {
<span class="nc" id="L123">    return BytesUtils.toASCIIBytes(String.valueOf(i).toCharArray());</span>
  }

  public static byte[] toAsciiBytes(double i) {
<span class="nc" id="L127">    return BytesUtils.toASCIIBytes(String.valueOf(i).toCharArray());</span>
  }

  /**
   * Returns the digit represented by character b.
   *
   * @param b     The ascii code of the character
   * @param radix The radix
   * @return -1 if it's invalid
   */
  static int digit(int b, int radix) {
<span class="nc" id="L138">    int r = -1;</span>
<span class="nc bnc" id="L139" title="All 4 branches missed.">    if (b &gt;= '0' &amp;&amp; b &lt;= '9') {</span>
<span class="nc" id="L140">      r = b - '0';</span>
<span class="nc bnc" id="L141" title="All 4 branches missed.">    } else if (b &gt;= 'A' &amp;&amp; b &lt;= 'Z') {</span>
<span class="nc" id="L142">      r = b - 'A' + 10;</span>
<span class="nc bnc" id="L143" title="All 4 branches missed.">    } else if (b &gt;= 'a' &amp;&amp; b &lt;= 'z') {</span>
<span class="nc" id="L144">      r = b - 'a' + 10;</span>
    }
<span class="nc bnc" id="L146" title="All 2 branches missed.">    if (r &gt;= radix) {</span>
<span class="nc" id="L147">      r = -1;</span>
    }
<span class="nc" id="L149">    return r;</span>
  }

  /**
   * Returns the digit represented by character b, radix is 10
   *
   * @param b The ascii code of the character
   * @return -1 if it's invalid
   */
  private static boolean isDigit(int b) {
<span class="nc bnc" id="L159" title="All 4 branches missed.">    return (b &gt;= '0' &amp;&amp; b &lt;= '9');</span>
  }

  /**
   * Parses the byte array argument as if it was a double value and returns the
   * result. Throws NumberFormatException if the byte array does not represent a
   * double value.
   *
   * @return double, the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as a double
   */
  public static double parseDouble(byte[] bytes, int start, int length) {
<span class="nc bnc" id="L171" title="All 2 branches missed.">    if (bytes == null) {</span>
<span class="nc" id="L172">      throw new NumberFormatException(&quot;String is null&quot;);</span>
    }
<span class="nc bnc" id="L174" title="All 2 branches missed.">    if (length == 0) {</span>
<span class="nc" id="L175">      throw new NumberFormatException(&quot;Empty byte array!&quot;);</span>
    }

    /*
     * Strip off leading blanks
     */
<span class="nc" id="L181">    int offset = start;</span>
<span class="nc" id="L182">    int end = start + length;</span>

<span class="nc bnc" id="L184" title="All 4 branches missed.">    while (offset &lt; end &amp;&amp; bytes[offset] == ' ') {</span>
<span class="nc" id="L185">      offset++;</span>
    }
<span class="nc bnc" id="L187" title="All 2 branches missed.">    if (offset == end) {</span>
<span class="nc" id="L188">      throw new NumberFormatException(&quot;blank byte array!&quot;);</span>
    }

    /*
     * check for a sign.
     */
<span class="nc" id="L194">    boolean sign = false;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">    if (bytes[offset] == '-') {</span>
<span class="nc" id="L196">      sign = true;</span>
<span class="nc" id="L197">      offset++;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">    } else if (bytes[offset] == '+') {</span>
<span class="nc" id="L199">      offset++;</span>
    }
<span class="nc bnc" id="L201" title="All 2 branches missed.">    if (offset == end) {</span>
<span class="nc" id="L202">      throw new NumberFormatException(&quot;the byte array only has a sign!&quot;);</span>
    }

    /*
     * Count the number of digits in the mantissa (including the decimal
     * point), and also locate the decimal point.
     */
<span class="nc" id="L209">    int mantSize = 0;		      /* Number of digits in mantissa. */</span>
<span class="nc" id="L210">    int decicalOffset = -1;   /* Number of mantissa digits BEFORE decimal point. */</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">    for (; offset &lt; end; offset++) {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      if (!isDigit(bytes[offset])) {</span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">        if ((bytes[offset] != '.') || (decicalOffset &gt;= 0)) {</span>
<span class="nc" id="L214">          break;</span>
        }
<span class="nc" id="L216">        decicalOffset = mantSize;</span>
      }
<span class="nc" id="L218">      mantSize++;</span>
    }

<span class="nc" id="L221">    int exponentOffset = offset; /* Temporarily holds location of exponent in bytes. */</span>

    /*
     * Now suck up the digits in the mantissa.  Use two integers to
     * collect 9 digits each (this is faster than using floating-point).
     * If the mantissa has more than 18 digits, ignore the extras, since
     * they can't affect the value anyway.
     */
<span class="nc" id="L229">    offset -= mantSize;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (decicalOffset &lt; 0) {</span>
<span class="nc" id="L231">      decicalOffset = mantSize;</span>
    } else {
<span class="nc" id="L233">      mantSize -= 1;			       /* One of the digits was the decimal point. */</span>
    }
    int fracExponent;            /* Exponent that derives from the fractional
                                  * part.  Under normal circumstatnces, it is
				                          * the negative of the number of digits in F.
				                          * However, if I is very long, the last digits
				                          * of I get dropped (otherwise a long I with a
				                          * large negative exponent could cause an
				                          * unnecessary overflow on I alone).  In this
				                          * case, fracExp is incremented one for each
				                          * dropped digit. */
<span class="nc bnc" id="L244" title="All 2 branches missed.">    if (mantSize &gt; 18) {</span>
<span class="nc" id="L245">      fracExponent = decicalOffset - 18;</span>
<span class="nc" id="L246">      mantSize = 18;</span>
    } else {
<span class="nc" id="L248">      fracExponent = decicalOffset - mantSize;</span>
    }

<span class="nc bnc" id="L251" title="All 2 branches missed.">    if (mantSize == 0) {</span>
<span class="nc" id="L252">      return 0.0;</span>
    }

<span class="nc" id="L255">    int frac1 = 0;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">    for (; mantSize &gt; 9; mantSize--) {</span>
<span class="nc" id="L257">      int b = bytes[offset];</span>
<span class="nc" id="L258">      offset++;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">      if (b == '.') {</span>
<span class="nc" id="L260">        b = bytes[offset];</span>
<span class="nc" id="L261">        offset++;</span>
      }
<span class="nc" id="L263">      frac1 = 10 * frac1 + (b - '0');</span>
    }
<span class="nc" id="L265">    int frac2 = 0;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">    for (; mantSize &gt; 0; mantSize--) {</span>
<span class="nc" id="L267">      int b = bytes[offset];</span>
<span class="nc" id="L268">      offset++;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">      if (b == '.') {</span>
<span class="nc" id="L270">        b = bytes[offset];</span>
<span class="nc" id="L271">        offset++;</span>
      }
<span class="nc" id="L273">      frac2 = 10 * frac2 + (b - '0');</span>
    }
<span class="nc" id="L275">    double fraction = (1.0e9 * frac1) + frac2;</span>

    /*
     * Skim off the exponent.
     */
<span class="nc" id="L280">    int exponent = 0;            /* Exponent read from &quot;EX&quot; field. */</span>
<span class="nc" id="L281">    offset = exponentOffset;</span>
<span class="nc" id="L282">    boolean expSign = false;</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">    if (offset &lt; end) {</span>
<span class="nc bnc" id="L285" title="All 4 branches missed.">      if ((bytes[offset] != 'E') &amp;&amp; (bytes[offset] != 'e')) {</span>
<span class="nc" id="L286">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }

      // (bytes[offset] == 'E') || (bytes[offset] == 'e')
<span class="nc" id="L291">      offset++;</span>

<span class="nc bnc" id="L293" title="All 2 branches missed.">      if (bytes[offset] == '-') {</span>
<span class="nc" id="L294">        expSign = true;</span>
<span class="nc" id="L295">        offset++;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">      } else if (bytes[offset] == '+') {</span>
<span class="nc" id="L297">        offset++;</span>
      }

<span class="nc bnc" id="L300" title="All 2 branches missed.">      for (; offset &lt; end; offset++) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (isDigit(bytes[offset])) {</span>
<span class="nc" id="L302">          exponent = exponent * 10 + (bytes[offset] - '0');</span>
        } else {
<span class="nc" id="L304">          throw new NumberFormatException(new String(bytes, start,</span>
              length));
        }
      }
    }

<span class="nc bnc" id="L310" title="All 2 branches missed.">    exponent = expSign ? (fracExponent - exponent) : (fracExponent + exponent);</span>

    /*
     * Generate a floating-point number that represents the exponent.
     * Do this by processing the exponent one bit at a time to combine
     * many powers of 2 of 10. Then combine the exponent with the
     * fraction.
     */
<span class="nc bnc" id="L318" title="All 2 branches missed.">    if (exponent &lt; 0) {</span>
<span class="nc" id="L319">      expSign = true;</span>
<span class="nc" id="L320">      exponent = -exponent;</span>
    } else {
<span class="nc" id="L322">      expSign = false;</span>
    }
<span class="nc bnc" id="L324" title="All 2 branches missed.">    if (exponent &gt; maxExponent) {</span>
<span class="nc" id="L325">      throw new NumberFormatException(new String(bytes, start,</span>
          length));
    }

<span class="nc" id="L329">    double dblExp = 1.0;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">    for (int i = 0; exponent != 0; exponent &gt;&gt;= 1, i++) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">      if ((exponent &amp; 01) == 01) {</span>
<span class="nc" id="L332">        dblExp *= powersOf10[i];</span>
      }
    }

<span class="nc bnc" id="L336" title="All 2 branches missed.">    fraction = (expSign) ? (fraction / dblExp) : (fraction * dblExp);</span>

<span class="nc bnc" id="L338" title="All 2 branches missed.">    return sign ? (-fraction) : fraction;</span>
  }

  /**
   * Parses the byte array argument as if it was an int value and returns the
   * result. Throws NumberFormatException if the byte array does not represent an
   * int quantity.
   *
   * @return int the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  public static int parseInt(byte[] bytes, int start, int length) {
<span class="nc" id="L350">    return parseInt(bytes, start, length, 10);</span>
  }

  /**
   * Parses the byte array argument as if it was an int value and returns the
   * result. Throws NumberFormatException if the byte array does not represent an
   * int quantity. The second argument specifies the radix to use when parsing
   * the value.
   *
   * @param radix the base to use for conversion.
   * @return the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  public static int parseInt(byte[] bytes, int start, int length, int radix) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">    if (bytes == null) {</span>
<span class="nc" id="L365">      throw new NumberFormatException(&quot;String is null&quot;);</span>
    }
<span class="nc bnc" id="L367" title="All 4 branches missed.">    if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX) {</span>
<span class="nc" id="L368">      throw new NumberFormatException(&quot;Invalid radix: &quot; + radix);</span>
    }
<span class="nc bnc" id="L370" title="All 2 branches missed.">    if (length == 0) {</span>
<span class="nc" id="L371">      throw new NumberFormatException(&quot;Empty byte array!&quot;);</span>
    }
<span class="nc" id="L373">    int offset = start;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">    boolean negative = bytes[start] == '-';</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">    if (negative || bytes[start] == '+') {</span>
<span class="nc" id="L376">      offset++;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">      if (length == 1) {</span>
<span class="nc" id="L378">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
    }

<span class="nc" id="L383">    return parseIntInternal(bytes, start, length, offset, radix, negative);</span>
  }

  /**
   * @param bytes
   * @param start
   * @param length
   * @param radix    the base to use for conversion.
   * @param offset   the starting position after the sign (if exists)
   * @param radix    the base to use for conversion.
   * @param negative whether the number is negative.
   * @return the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  private static int parseIntInternal(byte[] bytes, int start, int length, int offset,
                                      int radix, boolean negative) {
<span class="nc" id="L399">    byte separator = '.';</span>
<span class="nc" id="L400">    int max = Integer.MIN_VALUE / radix;</span>
<span class="nc" id="L401">    int result = 0, end = start + length;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">    while (offset &lt; end) {</span>
<span class="nc" id="L403">      int digit = digit(bytes[offset++], radix);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">      if (digit == -1) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (bytes[offset - 1] == separator) {</span>
          // We allow decimals and will return a truncated integer in that case.
          // Therefore we won't throw an exception here (checking the fractional
          // part happens below.)
<span class="nc" id="L409">          break;</span>
        }
<span class="nc" id="L411">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
<span class="nc bnc" id="L414" title="All 2 branches missed.">      if (max &gt; result) {</span>
<span class="nc" id="L415">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
<span class="nc" id="L418">      int next = result * radix - digit;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">      if (next &gt; result) {</span>
<span class="nc" id="L420">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
<span class="nc" id="L423">      result = next;</span>
<span class="nc" id="L424">    }</span>

    // This is the case when we've encountered a decimal separator. The fractional
    // part will not change the number, but we will verify that the fractional part
    // is well formed.
<span class="nc bnc" id="L429" title="All 2 branches missed.">    while (offset &lt; end) {</span>
<span class="nc" id="L430">      int digit = digit(bytes[offset++], radix);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">      if (digit == -1) {</span>
<span class="nc" id="L432">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
<span class="nc" id="L435">    }</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">    if (!negative) {</span>
<span class="nc" id="L438">      result = -result;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">      if (result &lt; 0) {</span>
<span class="nc" id="L440">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
    }
<span class="nc" id="L444">    return result;</span>
  }

  /**
   * Parses the string argument as if it was a long value and returns the
   * result. Throws NumberFormatException if the string does not represent a
   * long quantity.
   *
   * @param bytes
   * @param start
   * @param length a UTF-8 encoded string representation of a long quantity.
   * @return long the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as a long quantity.
   */
  public static long parseLong(byte[] bytes, int start, int length) {
<span class="nc" id="L459">    return parseLong(bytes, start, length, 10);</span>
  }

  /**
   * Parses the string argument as if it was an long value and returns the
   * result. Throws NumberFormatException if the string does not represent an
   * long quantity. The second argument specifies the radix to use when parsing
   * the value.
   *
   * @param bytes
   * @param start
   * @param length a UTF-8 encoded string representation of a long quantity.
   * @param radix  the base to use for conversion.
   * @return the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an long quantity.
   */
  public static long parseLong(byte[] bytes, int start, int length, int radix) {
<span class="nc bnc" id="L476" title="All 2 branches missed.">    if (bytes == null) {</span>
<span class="nc" id="L477">      throw new NumberFormatException(&quot;String is null&quot;);</span>
    }
<span class="nc bnc" id="L479" title="All 4 branches missed.">    if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX) {</span>
<span class="nc" id="L480">      throw new NumberFormatException(&quot;Invalid radix: &quot; + radix);</span>
    }
<span class="nc bnc" id="L482" title="All 2 branches missed.">    if (length == 0) {</span>
<span class="nc" id="L483">      throw new NumberFormatException(&quot;Empty string!&quot;);</span>
    }
<span class="nc" id="L485">    int offset = start;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">    boolean negative = bytes[start] == '-';</span>
<span class="nc bnc" id="L487" title="All 4 branches missed.">    if (negative || bytes[start] == '+') {</span>
<span class="nc" id="L488">      offset++;</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">      if (length == 1) {</span>
<span class="nc" id="L490">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
    }

<span class="nc" id="L495">    return parseLongInternal(bytes, start, length, offset, radix, negative);</span>
  }

  /**
   * /** Parses the string argument as if it was an long value and returns the
   * result. Throws NumberFormatException if the string does not represent an
   * long quantity. The second argument specifies the radix to use when parsing
   * the value.
   *
   * @param bytes
   * @param start
   * @param length   a UTF-8 encoded string representation of a long quantity.
   * @param offset   the starting position after the sign (if exists)
   * @param radix    the base to use for conversion.
   * @param negative whether the number is negative.
   * @return the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an long quantity.
   */
  private static long parseLongInternal(byte[] bytes, int start, int length, int offset,
                                        int radix, boolean negative) {
<span class="nc" id="L515">    byte separator = '.';</span>
<span class="nc" id="L516">    long max = Long.MIN_VALUE / radix;</span>
<span class="nc" id="L517">    long result = 0, end = start + length;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">    while (offset &lt; end) {</span>
<span class="nc" id="L519">      int digit = digit(bytes[offset++], radix);</span>
<span class="nc bnc" id="L520" title="All 4 branches missed.">      if (digit == -1 || max &gt; result) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (bytes[offset - 1] == separator) {</span>
          // We allow decimals and will return a truncated integer in that case.
          // Therefore we won't throw an exception here (checking the fractional
          // part happens below.)
<span class="nc" id="L525">          break;</span>
        }
<span class="nc" id="L527">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
<span class="nc" id="L530">      long next = result * radix - digit;</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">      if (next &gt; result) {</span>
<span class="nc" id="L532">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
<span class="nc" id="L535">      result = next;</span>
<span class="nc" id="L536">    }</span>

    // This is the case when we've encountered a decimal separator. The fractional
    // part will not change the number, but we will verify that the fractional part
    // is well formed.
<span class="nc bnc" id="L541" title="All 2 branches missed.">    while (offset &lt; end) {</span>
<span class="nc" id="L542">      int digit = digit(bytes[offset++], radix);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">      if (digit == -1) {</span>
<span class="nc" id="L544">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
<span class="nc" id="L547">    }</span>

<span class="nc bnc" id="L549" title="All 2 branches missed.">    if (!negative) {</span>
<span class="nc" id="L550">      result = -result;</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">      if (result &lt; 0) {</span>
<span class="nc" id="L552">        throw new NumberFormatException(new String(bytes, start,</span>
            length));
      }
    }
<span class="nc" id="L556">    return result;</span>
  }

  /**
   * Writes out the text representation of an integer using base 10 to an
   * OutputStream in UTF-8 encoding.
   * &lt;p/&gt;
   * Note: division by a constant (like 10) is much faster than division by a
   * variable. That's one of the reasons that we don't make radix a parameter
   * here.
   *
   * @param out the outputstream to write to
   * @param i   an int to write out
   * @throws IOException
   */
  public static void writeUTF8(OutputStream out, int i) throws IOException {
<span class="nc bnc" id="L572" title="All 2 branches missed.">    if (i == 0) {</span>
<span class="nc" id="L573">      out.write('0');</span>
<span class="nc" id="L574">      return;</span>
    }

<span class="nc bnc" id="L577" title="All 2 branches missed.">    boolean negative = i &lt; 0;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">    if (negative) {</span>
<span class="nc" id="L579">      out.write('-');</span>
    } else {
      // negative range is bigger than positive range, so there is no risk
      // of overflow here.
<span class="nc" id="L583">      i = -i;</span>
    }

<span class="nc" id="L586">    int start = 1000000000;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">    while (i / start == 0) {</span>
<span class="nc" id="L588">      start /= 10;</span>
    }

<span class="nc bnc" id="L591" title="All 2 branches missed.">    while (start &gt; 0) {</span>
<span class="nc" id="L592">      out.write('0' - (i / start % 10));</span>
<span class="nc" id="L593">      start /= 10;</span>
    }
<span class="nc" id="L595">  }</span>

  /**
   * Writes out the text representation of an integer using base 10 to an
   * OutputStream in UTF-8 encoding.
   * &lt;p/&gt;
   * Note: division by a constant (like 10) is much faster than division by a
   * variable. That's one of the reasons that we don't make radix a parameter
   * here.
   *
   * @param out the outputstream to write to
   * @param i   an int to write out
   * @throws java.io.IOException
   */
  public static void writeUTF8(OutputStream out, long i) throws IOException {
<span class="nc bnc" id="L610" title="All 2 branches missed.">    if (i == 0) {</span>
<span class="nc" id="L611">      out.write('0');</span>
<span class="nc" id="L612">      return;</span>
    }

<span class="nc bnc" id="L615" title="All 2 branches missed.">    boolean negative = i &lt; 0;</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">    if (negative) {</span>
<span class="nc" id="L617">      out.write('-');</span>
    } else {
      // negative range is bigger than positive range, so there is no risk
      // of overflow here.
<span class="nc" id="L621">      i = -i;</span>
    }

<span class="nc" id="L624">    long start = 1000000000000000000L;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">    while (i / start == 0) {</span>
<span class="nc" id="L626">      start /= 10;</span>
    }

<span class="nc bnc" id="L629" title="All 2 branches missed.">    while (start &gt; 0) {</span>
<span class="nc" id="L630">      out.write('0' - (int) ((i / start) % 10));</span>
<span class="nc" id="L631">      start /= 10;</span>
    }
<span class="nc" id="L633">  }</span>

  /**
   * Parses the byte array argument as if it was a double value and returns the
   * result. Throws NumberFormatException if the byte buffer does not represent a
   * double value.
   *
   * @return double, the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as a double
   */
  public static double parseDouble(ByteBuf bytes) {
<span class="nc" id="L644">    return parseDouble(bytes, bytes.readerIndex(), bytes.readableBytes());</span>
  }

  /**
   * Parses the byte array argument as if it was a double value and returns the
   * result. Throws NumberFormatException if the byte buffer does not represent a
   * double value.
   *
   * @return double, the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as a double
   */
  public static double parseDouble(ByteBuf bytes, int start, int length) {
<span class="nc bnc" id="L656" title="All 2 branches missed.">    if (bytes == null) {</span>
<span class="nc" id="L657">      throw new NumberFormatException(&quot;String is null&quot;);</span>
    }

<span class="nc bnc" id="L660" title="All 2 branches missed.">    if (!bytes.hasMemoryAddress()) {</span>
<span class="nc" id="L661">      return parseDouble(bytes.array(), start, length);</span>
    }

<span class="nc bnc" id="L664" title="All 4 branches missed.">    if (length == 0 || bytes.writerIndex() &lt; start + length) {</span>
<span class="nc" id="L665">      throw new NumberFormatException(&quot;Empty string or Invalid buffer!&quot;);</span>
    }


<span class="nc" id="L669">    long memoryAddress = bytes.memoryAddress();</span>
    /*
     * Strip off leading blanks
     */
<span class="nc" id="L673">    int offset = start;</span>
<span class="nc" id="L674">    int end = start + length;</span>

<span class="nc bnc" id="L676" title="All 4 branches missed.">    while (offset &lt; end &amp;&amp; PlatformDependent.getByte(memoryAddress + offset) == ' ') {</span>
<span class="nc" id="L677">      offset++;</span>
    }
<span class="nc bnc" id="L679" title="All 2 branches missed.">    if (offset == end) {</span>
<span class="nc" id="L680">      throw new NumberFormatException(&quot;blank byte array!&quot;);</span>
    }

    /*
     * check for a sign.
     */
<span class="nc" id="L686">    boolean sign = false;</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">    if (PlatformDependent.getByte(memoryAddress + offset) == '-') {</span>
<span class="nc" id="L688">      sign = true;</span>
<span class="nc" id="L689">      offset++;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">    } else if (PlatformDependent.getByte(memoryAddress + offset) == '+') {</span>
<span class="nc" id="L691">      offset++;</span>
    }
<span class="nc bnc" id="L693" title="All 2 branches missed.">    if (offset == end) {</span>
<span class="nc" id="L694">      throw new NumberFormatException(&quot;the byte array only has a sign!&quot;);</span>
    }

    /*
     * Count the number of digits in the mantissa (including the decimal
     * point), and also locate the decimal point.
     */
<span class="nc" id="L701">    int mantSize = 0;		      /* Number of digits in mantissa. */</span>
<span class="nc" id="L702">    int decicalOffset = -1;   /* Number of mantissa digits BEFORE decimal point. */</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">    for (; offset &lt; end; offset++) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">      if (!isDigit(PlatformDependent.getByte(memoryAddress + offset))) {</span>
<span class="nc bnc" id="L705" title="All 4 branches missed.">        if ((PlatformDependent.getByte(memoryAddress + offset) != '.') || (decicalOffset &gt;= 0)) {</span>
<span class="nc" id="L706">          break;</span>
        }
<span class="nc" id="L708">        decicalOffset = mantSize;</span>
      }
<span class="nc" id="L710">      mantSize++;</span>
    }

<span class="nc" id="L713">    int exponentOffset = offset; /* Temporarily holds location of exponent in bytes. */</span>

    /*
     * Now suck up the digits in the mantissa.  Use two integers to
     * collect 9 digits each (this is faster than using floating-point).
     * If the mantissa has more than 18 digits, ignore the extras, since
     * they can't affect the value anyway.
     */
<span class="nc" id="L721">    offset -= mantSize;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">    if (decicalOffset &lt; 0) {</span>
<span class="nc" id="L723">      decicalOffset = mantSize;</span>
    } else {
<span class="nc" id="L725">      mantSize -= 1;			       /* One of the digits was the decimal point. */</span>
    }
    int fracExponent;            /* Exponent that derives from the fractional
                                  * part.  Under normal circumstatnces, it is
				                          * the negative of the number of digits in F.
				                          * However, if I is very long, the last digits
				                          * of I get dropped (otherwise a long I with a
				                          * large negative exponent could cause an
				                          * unnecessary overflow on I alone).  In this
				                          * case, fracExp is incremented one for each
				                          * dropped digit. */
<span class="nc bnc" id="L736" title="All 2 branches missed.">    if (mantSize &gt; 18) {</span>
<span class="nc" id="L737">      fracExponent = decicalOffset - 18;</span>
<span class="nc" id="L738">      mantSize = 18;</span>
    } else {
<span class="nc" id="L740">      fracExponent = decicalOffset - mantSize;</span>
    }

<span class="nc bnc" id="L743" title="All 2 branches missed.">    if (mantSize == 0) {</span>
<span class="nc" id="L744">      return 0.0;</span>
    }

<span class="nc" id="L747">    int frac1 = 0;</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">    for (; mantSize &gt; 9; mantSize--) {</span>
<span class="nc" id="L749">      int b = PlatformDependent.getByte(memoryAddress + offset);</span>
<span class="nc" id="L750">      offset++;</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">      if (b == '.') {</span>
<span class="nc" id="L752">        b = PlatformDependent.getByte(memoryAddress + offset);</span>
<span class="nc" id="L753">        offset++;</span>
      }
<span class="nc" id="L755">      frac1 = 10 * frac1 + (b - '0');</span>
    }
<span class="nc" id="L757">    int frac2 = 0;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">    for (; mantSize &gt; 0; mantSize--) {</span>
<span class="nc" id="L759">      int b = PlatformDependent.getByte(memoryAddress + offset);</span>
<span class="nc" id="L760">      offset++;</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">      if (b == '.') {</span>
<span class="nc" id="L762">        b = PlatformDependent.getByte(memoryAddress + offset);</span>
<span class="nc" id="L763">        offset++;</span>
      }
<span class="nc" id="L765">      frac2 = 10 * frac2 + (b - '0');</span>
    }
<span class="nc" id="L767">    double fraction = (1.0e9 * frac1) + frac2;</span>

    /*
     * Skim off the exponent.
     */
<span class="nc" id="L772">    int exponent = 0;            /* Exponent read from &quot;EX&quot; field. */</span>
<span class="nc" id="L773">    offset = exponentOffset;</span>
<span class="nc" id="L774">    boolean expSign = false;</span>

<span class="nc bnc" id="L776" title="All 2 branches missed.">    if (offset &lt; end) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">      if ((PlatformDependent.getByte(memoryAddress + offset) != 'E')</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">          &amp;&amp; (PlatformDependent.getByte(memoryAddress + offset) != 'e')) {</span>
<span class="nc" id="L779">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }

      // (bytes[offset] == 'E') || (bytes[offset] == 'e')
<span class="nc" id="L783">      offset++;</span>

<span class="nc bnc" id="L785" title="All 2 branches missed.">      if (PlatformDependent.getByte(memoryAddress + offset) == '-') {</span>
<span class="nc" id="L786">        expSign = true;</span>
<span class="nc" id="L787">        offset++;</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">      } else if (PlatformDependent.getByte(memoryAddress + offset) == '+') {</span>
<span class="nc" id="L789">        offset++;</span>
      }

<span class="nc bnc" id="L792" title="All 2 branches missed.">      for (; offset &lt; end; offset++) {</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">        if (isDigit(PlatformDependent.getByte(memoryAddress + offset))) {</span>
<span class="nc" id="L794">          exponent = exponent * 10 + (PlatformDependent.getByte(memoryAddress + offset) - '0');</span>
        } else {
<span class="nc" id="L796">          throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
        }
      }
    }

<span class="nc bnc" id="L801" title="All 2 branches missed.">    exponent = expSign ? (fracExponent - exponent) : (fracExponent + exponent);</span>

    /*
     * Generate a floating-point number that represents the exponent.
     * Do this by processing the exponent one bit at a time to combine
     * many powers of 2 of 10. Then combine the exponent with the
     * fraction.
     */
<span class="nc bnc" id="L809" title="All 2 branches missed.">    if (exponent &lt; 0) {</span>
<span class="nc" id="L810">      expSign = true;</span>
<span class="nc" id="L811">      exponent = -exponent;</span>
    } else {
<span class="nc" id="L813">      expSign = false;</span>
    }
<span class="nc bnc" id="L815" title="All 2 branches missed.">    if (exponent &gt; maxExponent) {</span>
<span class="nc" id="L816">      throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
    }

<span class="nc" id="L819">    double dblExp = 1.0;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">    for (int i = 0; exponent != 0; exponent &gt;&gt;= 1, i++) {</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">      if ((exponent &amp; 01) == 01) {</span>
<span class="nc" id="L822">        dblExp *= powersOf10[i];</span>
      }
    }

<span class="nc bnc" id="L826" title="All 2 branches missed.">    fraction = (expSign) ? (fraction / dblExp) : (fraction * dblExp);</span>

<span class="nc bnc" id="L828" title="All 2 branches missed.">    return sign ? (-fraction) : fraction;</span>
  }


  /**
   * Parses the byte buffer argument as if it was an int value and returns the
   * result. Throws NumberFormatException if the byte array does not represent an
   * int quantity.
   *
   * @return int the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  public static int parseInt(ByteBuf bytes) {
<span class="nc" id="L841">    return parseInt(bytes, bytes.readerIndex(), bytes.readableBytes());</span>
  }

  /**
   * Parses the byte buffer argument as if it was an int value and returns the
   * result. Throws NumberFormatException if the byte array does not represent an
   * int quantity.
   *
   * @return int the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  public static int parseInt(ByteBuf bytes, int start, int length) {
<span class="nc" id="L853">    return parseInt(bytes, start, length, 10);</span>
  }

  /**
   * Parses the byte buffer argument as if it was an int value and returns the
   * result. Throws NumberFormatException if the byte array does not represent an
   * int quantity. The second argument specifies the radix to use when parsing
   * the value.
   *
   * @param radix the base to use for conversion.
   * @return the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  public static int parseInt(ByteBuf bytes, int start, int length, int radix) {
<span class="nc bnc" id="L867" title="All 2 branches missed.">    if (bytes == null) {</span>
<span class="nc" id="L868">      throw new NumberFormatException(&quot;String is null&quot;);</span>
    }

<span class="nc bnc" id="L871" title="All 2 branches missed.">    if (!bytes.hasMemoryAddress()) {</span>
<span class="nc" id="L872">      return parseInt(bytes.array(), start, length);</span>
    }

<span class="nc bnc" id="L875" title="All 4 branches missed.">    if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX) {</span>
<span class="nc" id="L876">      throw new NumberFormatException(&quot;Invalid radix: &quot; + radix);</span>
    }
<span class="nc bnc" id="L878" title="All 4 branches missed.">    if (length == 0 || bytes.writerIndex() &lt; start + length) {</span>
<span class="nc" id="L879">      throw new NumberFormatException(&quot;Empty string or Invalid buffer!&quot;);</span>
    }

<span class="nc" id="L882">    long memoryAddress = bytes.memoryAddress();</span>

<span class="nc" id="L884">    int offset = start;</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">    boolean negative = PlatformDependent.getByte(memoryAddress + start) == '-';</span>
<span class="nc bnc" id="L886" title="All 4 branches missed.">    if (negative || PlatformDependent.getByte(memoryAddress + start) == '+') {</span>
<span class="nc" id="L887">      offset++;</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">      if (length == 1) {</span>
<span class="nc" id="L889">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
    }

<span class="nc" id="L893">    return parseIntInternal(bytes, memoryAddress, start, length, offset, radix, negative);</span>
  }

  /**
   * @param bytes         the string byte buffer
   * @param memoryAddress the offheap memory address
   * @param start
   * @param length
   * @param radix         the base to use for conversion.
   * @param offset        the starting position after the sign (if exists)
   * @param radix         the base to use for conversion.
   * @param negative      whether the number is negative.
   * @return the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  private static int parseIntInternal(ByteBuf bytes, long memoryAddress, int start, int length, int offset,
                                      int radix, boolean negative) {
<span class="nc" id="L910">    byte separator = '.';</span>
<span class="nc" id="L911">    int max = Integer.MIN_VALUE / radix;</span>
<span class="nc" id="L912">    int result = 0, end = start + length;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">    while (offset &lt; end) {</span>
<span class="nc" id="L914">      int digit = digit(PlatformDependent.getByte(memoryAddress + offset++), radix);</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">      if (digit == -1) {</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">        if (PlatformDependent.getByte(memoryAddress + offset - 1) == separator) {</span>
          // We allow decimals and will return a truncated integer in that case.
          // Therefore we won't throw an exception here (checking the fractional
          // part happens below.)
<span class="nc" id="L920">          break;</span>
        }
<span class="nc" id="L922">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
<span class="nc bnc" id="L924" title="All 2 branches missed.">      if (max &gt; result) {</span>
<span class="nc" id="L925">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
<span class="nc" id="L927">      int next = result * radix - digit;</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">      if (next &gt; result) {</span>
<span class="nc" id="L929">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
<span class="nc" id="L931">      result = next;</span>
<span class="nc" id="L932">    }</span>

    // This is the case when we've encountered a decimal separator. The fractional
    // part will not change the number, but we will verify that the fractional part
    // is well formed.
<span class="nc bnc" id="L937" title="All 2 branches missed.">    while (offset &lt; end) {</span>
<span class="nc" id="L938">      int digit = digit(PlatformDependent.getByte(memoryAddress + offset++), radix);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">      if (digit == -1) {</span>
<span class="nc" id="L940">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
<span class="nc" id="L942">    }</span>

<span class="nc bnc" id="L944" title="All 2 branches missed.">    if (!negative) {</span>
<span class="nc" id="L945">      result = -result;</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">      if (result &lt; 0) {</span>
<span class="nc" id="L947">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
    }
<span class="nc" id="L950">    return result;</span>
  }

  /**
   * Parses the byte buffer argument as if it was a long value and returns the
   * result. Throws NumberFormatException if the string does not represent a
   * long quantity.
   *
   * @param bytes the string byte buffer
   * @return long the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as a long quantity.
   */
  public static long parseLong(ByteBuf bytes) {
<span class="nc" id="L963">    return parseLong(bytes, bytes.readerIndex(), bytes.readableBytes());</span>
  }

  /**
   * Parses the byte buffer argument as if it was a long value and returns the
   * result. Throws NumberFormatException if the string does not represent a
   * long quantity.
   *
   * @param bytes  the string byte buffer
   * @param start
   * @param length a UTF-8 encoded string representation of a long quantity.
   * @return long the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as a long quantity.
   */
  public static long parseLong(ByteBuf bytes, int start, int length) {
<span class="nc" id="L978">    return parseLong(bytes, start, length, 10);</span>
  }

  /**
   * Parses the byte buffer argument as if it was an long value and returns the
   * result. Throws NumberFormatException if the string does not represent an
   * long quantity. The second argument specifies the radix to use when parsing
   * the value.
   *
   * @param bytes  the string byte buffer
   * @param start
   * @param length a UTF-8 encoded string representation of a long quantity.
   * @param radix  the base to use for conversion.
   * @return the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an long quantity.
   */
  public static long parseLong(ByteBuf bytes, int start, int length, int radix) {
<span class="nc bnc" id="L995" title="All 2 branches missed.">    if (bytes == null) {</span>
<span class="nc" id="L996">      throw new NumberFormatException(&quot;String is null&quot;);</span>
    }

<span class="nc bnc" id="L999" title="All 2 branches missed.">    if (!bytes.hasMemoryAddress()) {</span>
<span class="nc" id="L1000">      return parseInt(bytes.array(), start, length);</span>
    }

<span class="nc bnc" id="L1003" title="All 4 branches missed.">    if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX) {</span>
<span class="nc" id="L1004">      throw new NumberFormatException(&quot;Invalid radix: &quot; + radix);</span>
    }
<span class="nc bnc" id="L1006" title="All 4 branches missed.">    if (length == 0 || bytes.writerIndex() &lt; start + length) {</span>
<span class="nc" id="L1007">      throw new NumberFormatException(&quot;Empty string or Invalid buffer!&quot;);</span>
    }

<span class="nc" id="L1010">    long memoryAddress = bytes.memoryAddress();</span>

<span class="nc" id="L1012">    int offset = start;</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">    boolean negative = PlatformDependent.getByte(memoryAddress + start) == '-';</span>
<span class="nc bnc" id="L1014" title="All 4 branches missed.">    if (negative || PlatformDependent.getByte(memoryAddress + start) == '+') {</span>
<span class="nc" id="L1015">      offset++;</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">      if (length == 1) {</span>
<span class="nc" id="L1017">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
    }

<span class="nc" id="L1021">    return parseLongInternal(bytes, memoryAddress, start, length, offset, radix, negative);</span>
  }

  /**
   * /** Parses the byte buffer argument as if it was an long value and returns the
   * result. Throws NumberFormatException if the string does not represent an
   * long quantity. The second argument specifies the radix to use when parsing
   * the value.
   *
   * @param bytes         the string byte buffer
   * @param memoryAddress the offheap memory address
   * @param start
   * @param length        a UTF-8 encoded string representation of a long quantity.
   * @param offset        the starting position after the sign (if exists)
   * @param radix         the base to use for conversion.
   * @param negative      whether the number is negative.
   * @return the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an long quantity.
   */
  private static long parseLongInternal(ByteBuf bytes, long memoryAddress, int start, int length, int offset,
                                        int radix, boolean negative) {
<span class="nc" id="L1042">    byte separator = '.';</span>
<span class="nc" id="L1043">    long max = Long.MIN_VALUE / radix;</span>
<span class="nc" id="L1044">    long result = 0, end = start + length;</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">    while (offset &lt; end) {</span>
<span class="nc" id="L1046">      int digit = digit(PlatformDependent.getByte(memoryAddress + offset++), radix);</span>
<span class="nc bnc" id="L1047" title="All 4 branches missed.">      if (digit == -1 || max &gt; result) {</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">        if (PlatformDependent.getByte(memoryAddress + offset - 1) == separator) {</span>
          // We allow decimals and will return a truncated integer in that case.
          // Therefore we won't throw an exception here (checking the fractional
          // part happens below.)
<span class="nc" id="L1052">          break;</span>
        }
<span class="nc" id="L1054">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
<span class="nc" id="L1056">      long next = result * radix - digit;</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">      if (next &gt; result) {</span>
<span class="nc" id="L1058">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
<span class="nc" id="L1060">      result = next;</span>
<span class="nc" id="L1061">    }</span>

    // This is the case when we've encountered a decimal separator. The fractional
    // part will not change the number, but we will verify that the fractional part
    // is well formed.
<span class="nc bnc" id="L1066" title="All 2 branches missed.">    while (offset &lt; end) {</span>
<span class="nc" id="L1067">      int digit = digit(PlatformDependent.getByte(memoryAddress + offset++), radix);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">      if (digit == -1) {</span>
<span class="nc" id="L1069">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
<span class="nc" id="L1071">    }</span>

<span class="nc bnc" id="L1073" title="All 2 branches missed.">    if (!negative) {</span>
<span class="nc" id="L1074">      result = -result;</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">      if (result &lt; 0) {</span>
<span class="nc" id="L1076">        throw new NumberFormatException(bytes.toString(start, length, Charset.defaultCharset()));</span>
      }
    }
<span class="nc" id="L1079">    return result;</span>
  }

  public static Number numberValue(Class&lt;?&gt; numberClazz, String value) {
<span class="nc" id="L1083">    Number returnNumber = null;</span>

<span class="nc bnc" id="L1085" title="All 4 branches missed.">    if (numberClazz == null &amp;&amp; value == null) {</span>
<span class="nc" id="L1086">      return returnNumber;</span>
    }

<span class="nc bnc" id="L1089" title="All 2 branches missed.">    if (Number.class.isAssignableFrom(numberClazz)) {</span>
        try {
<span class="nc" id="L1091">          Constructor&lt;?&gt; constructor = numberClazz.getConstructor(String.class);</span>
<span class="nc" id="L1092">          returnNumber = (Number) constructor.newInstance(value);</span>
<span class="nc" id="L1093">        } catch (RuntimeException e) {</span>
<span class="nc" id="L1094">          throw e;</span>
<span class="nc" id="L1095">        } catch (Exception ignored) {</span>
<span class="nc" id="L1096">        }</span>
      
    }

<span class="nc" id="L1100">    return returnNumber;</span>
  }

  public static int compare(long x, long y) {
<span class="nc bnc" id="L1104" title="All 4 branches missed.">    return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);</span>
  }

  /**
   * Put bytes at the specified byte array position.
   * @param tgtBytes the byte array
   * @param tgtOffset position in the array
   * @param srcBytes array to write out
   * @param srcOffset source offset
   * @param srcLength source length
   * @return incremented offset
   */
  public static int putBytes(byte[] tgtBytes, int tgtOffset, byte[] srcBytes,
                             int srcOffset, int srcLength) {
<span class="nc" id="L1118">    System.arraycopy(srcBytes, srcOffset, tgtBytes, tgtOffset, srcLength);</span>
<span class="nc" id="L1119">    return tgtOffset + srcLength;</span>
  }

  /**
   * Returns a new byte array, copied from the given {@code buf},
   * from the index 0 (inclusive) to the limit (exclusive),
   * regardless of the current position.
   * The position and the other index parameters are not changed.
   *
   * @param buf a byte buffer
   * @return the byte array
   * @see #getBytes(ByteBuffer)
   */
  public static byte[] toBytes(ByteBuffer buf) {
<span class="nc" id="L1133">    ByteBuffer dup = buf.duplicate();</span>
<span class="nc" id="L1134">    dup.position(0);</span>
<span class="nc" id="L1135">    return readBytes(dup);</span>
  }

  private static byte[] readBytes(ByteBuffer buf) {
<span class="nc" id="L1139">    byte [] result = new byte[buf.remaining()];</span>
<span class="nc" id="L1140">    buf.get(result);</span>
<span class="nc" id="L1141">    return result;</span>
  }

  /**
   * Converts a string to a UTF-8 byte array.
   * @param s string
   * @return the byte array
   */
  public static byte[] toBytes(String s) {
<span class="nc" id="L1150">    return s.getBytes(UTF8_CHARSET);</span>
  }

  /**
   * Convert a boolean to a byte array. True becomes -1
   * and false becomes 0.
   *
   * @param b value
   * @return &lt;code&gt;b&lt;/code&gt; encoded in a byte array.
   */
  public static byte [] toBytes(final boolean b) {
<span class="nc bnc" id="L1161" title="All 2 branches missed.">    return new byte[] { b ? (byte) -1 : (byte) 0 };</span>
  }

  /**
   * Reverses {@link #toBytes(boolean)}
   * @param b array
   * @return True or false.
   */
  public static boolean toBoolean(final byte [] b) {
<span class="nc bnc" id="L1170" title="All 2 branches missed.">    if (b.length != 1) {</span>
<span class="nc" id="L1171">      throw new IllegalArgumentException(&quot;Array has wrong size: &quot; + b.length);</span>
    }
<span class="nc bnc" id="L1173" title="All 2 branches missed.">    return b[0] != (byte) 0;</span>
  }

  /**
   * Convert a long value to a byte array using big-endian.
   *
   * @param val value to convert
   * @return the byte array
   */
  public static byte[] toBytes(long val) {
<span class="nc" id="L1183">    byte [] b = new byte[8];</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">    for (int i = 7; i &gt; 0; i--) {</span>
<span class="nc" id="L1185">      b[i] = (byte) val;</span>
<span class="nc" id="L1186">      val &gt;&gt;&gt;= 8;</span>
    }
<span class="nc" id="L1188">    b[0] = (byte) val;</span>
<span class="nc" id="L1189">    return b;</span>
  }

  /**
   * Converts a byte array to a long value. Reverses
   * {@link #toBytes(long)}
   * @param bytes array
   * @return the long value
   */
  public static long toLong(byte[] bytes) {
<span class="nc" id="L1199">    return toLong(bytes, 0, SIZEOF_LONG);</span>
  }

  /**
   * Converts a byte array to a long value. Assumes there will be
   * {@link #SIZEOF_LONG} bytes available.
   *
   * @param bytes bytes
   * @param offset offset
   * @return the long value
   */
  public static long toLong(byte[] bytes, int offset) {
<span class="nc" id="L1211">    return toLong(bytes, offset, SIZEOF_LONG);</span>
  }

  /**
   * Converts a byte array to a long value.
   *
   * @param bytes array of bytes
   * @param offset offset into array
   * @param length length of data (must be {@link #SIZEOF_LONG})
   * @return the long value
   * @throws IllegalArgumentException if length is not {@link #SIZEOF_LONG} or
   * if there's not enough room in the array at the offset indicated.
   */
  public static long toLong(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L1225" title="All 4 branches missed.">    if (length != SIZEOF_LONG || offset + length &gt; bytes.length) {</span>
<span class="nc" id="L1226">      throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_LONG);</span>
    }
<span class="nc" id="L1228">    long l = 0;</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">    for(int i = offset; i &lt; offset + length; i++) {</span>
<span class="nc" id="L1230">      l &lt;&lt;= 8;</span>
<span class="nc" id="L1231">      l ^= bytes[i] &amp; 0xFF;</span>
    }
<span class="nc" id="L1233">    return l;</span>
  }

  private static IllegalArgumentException
  explainWrongLengthOrOffset(final byte[] bytes,
                             final int offset,
                             final int length,
                             final int expectedLength) {
    String reason;
<span class="nc bnc" id="L1242" title="All 2 branches missed.">    if (length != expectedLength) {</span>
<span class="nc" id="L1243">      reason = &quot;Wrong length: &quot; + length + &quot;, expected &quot; + expectedLength;</span>
    } else {
<span class="nc" id="L1245">      reason = &quot;offset (&quot; + offset + &quot;) + length (&quot; + length + &quot;) exceed the&quot;</span>
          + &quot; capacity of the array: &quot; + bytes.length;
    }
<span class="nc" id="L1248">    return new IllegalArgumentException(reason);</span>
  }

  /**
   * Put a long value out to the specified byte array position.
   * @param bytes the byte array
   * @param offset position in the array
   * @param val long to write out
   * @return incremented offset
   * @throws IllegalArgumentException if the byte array given doesn't have
   * enough room at the offset specified.
   */
  public static int putLong(byte[] bytes, int offset, long val) {
<span class="nc bnc" id="L1261" title="All 2 branches missed.">    if (bytes.length - offset &lt; SIZEOF_LONG) {</span>
<span class="nc" id="L1262">      throw new IllegalArgumentException(&quot;Not enough room to put a long at&quot;</span>
          + &quot; offset &quot; + offset + &quot; in a &quot; + bytes.length + &quot; byte array&quot;);
    }
<span class="nc bnc" id="L1265" title="All 2 branches missed.">    for(int i = offset + 7; i &gt; offset; i--) {</span>
<span class="nc" id="L1266">      bytes[i] = (byte) val;</span>
<span class="nc" id="L1267">      val &gt;&gt;&gt;= 8;</span>
    }
<span class="nc" id="L1269">    bytes[offset] = (byte) val;</span>
<span class="nc" id="L1270">    return offset + SIZEOF_LONG;</span>
  }

  /**
   * Presumes float encoded as IEEE 754 floating-point &quot;single format&quot;
   * @param bytes byte array
   * @return Float made from passed byte array.
   */
  public static float toFloat(byte [] bytes) {
<span class="nc" id="L1279">    return toFloat(bytes, 0);</span>
  }

  /**
   * Presumes float encoded as IEEE 754 floating-point &quot;single format&quot;
   * @param bytes array to convert
   * @param offset offset into array
   * @return Float made from passed byte array.
   */
  public static float toFloat(byte [] bytes, int offset) {
<span class="nc" id="L1289">    return Float.intBitsToFloat(toInt(bytes, offset, SIZEOF_INT));</span>
  }

  /**
   * @param bytes byte array
   * @param offset offset to write to
   * @param f float value
   * @return New offset in &lt;code&gt;bytes&lt;/code&gt;
   */
  public static int putFloat(byte [] bytes, int offset, float f) {
<span class="nc" id="L1299">    return putInt(bytes, offset, Float.floatToRawIntBits(f));</span>
  }

  /**
   * @param f float value
   * @return the float represented as byte []
   */
  public static byte [] toBytes(final float f) {
    // Encode it as int
<span class="nc" id="L1308">    return Bytes.toBytes(Float.floatToRawIntBits(f));</span>
  }

  /**
   * @param bytes byte array
   * @return Return double made from passed bytes.
   */
  public static double toDouble(final byte [] bytes) {
<span class="nc" id="L1316">    return toDouble(bytes, 0);</span>
  }

  /**
   * @param bytes byte array
   * @param offset offset where double is
   * @return Return double made from passed bytes.
   */
  public static double toDouble(final byte [] bytes, final int offset) {
<span class="nc" id="L1325">    return Double.longBitsToDouble(toLong(bytes, offset, SIZEOF_LONG));</span>
  }

  /**
   * @param bytes byte array
   * @param offset offset to write to
   * @param d value
   * @return New offset into array &lt;code&gt;bytes&lt;/code&gt;
   */
  public static int putDouble(byte [] bytes, int offset, double d) {
<span class="nc" id="L1335">    return putLong(bytes, offset, Double.doubleToLongBits(d));</span>
  }

  /**
   * Serialize a double as the IEEE 754 double format output. The resultant
   * array will be 8 bytes long.
   *
   * @param d value
   * @return the double represented as byte []
   */
  public static byte [] toBytes(final double d) {
    // Encode it as a long
<span class="nc" id="L1347">    return Bytes.toBytes(Double.doubleToRawLongBits(d));</span>
  }

  /**
   * Convert an int value to a byte array.  Big-endian.  Same as what DataOutputStream.writeInt
   * does.
   *
   * @param val value
   * @return the byte array
   */
  public static byte[] toBytes(int val) {
<span class="nc" id="L1358">    byte [] b = new byte[4];</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">    for(int i = 3; i &gt; 0; i--) {</span>
<span class="nc" id="L1360">      b[i] = (byte) val;</span>
<span class="nc" id="L1361">      val &gt;&gt;&gt;= 8;</span>
    }
<span class="nc" id="L1363">    b[0] = (byte) val;</span>
<span class="nc" id="L1364">    return b;</span>
  }

  /**
   * Converts a byte array to an int value
   * @param bytes byte array
   * @return the int value
   */
  public static int toInt(byte[] bytes) {
<span class="nc" id="L1373">    return toInt(bytes, 0, SIZEOF_INT);</span>
  }

  /**
   * Converts a byte array to an int value
   * @param bytes byte array
   * @param offset offset into array
   * @return the int value
   */
  public static int toInt(byte[] bytes, int offset) {
<span class="nc" id="L1383">    return toInt(bytes, offset, SIZEOF_INT);</span>
  }

  /**
   * Converts a byte array to an int value
   * @param bytes byte array
   * @param offset offset into array
   * @param length length of int (has to be {@link #SIZEOF_INT})
   * @return the int value
   * @throws IllegalArgumentException if length is not {@link #SIZEOF_INT} or
   * if there's not enough room in the array at the offset indicated.
   */
  public static int toInt(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L1396" title="All 4 branches missed.">    if (length != SIZEOF_INT || offset + length &gt; bytes.length) {</span>
<span class="nc" id="L1397">      throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_INT);</span>
    }
<span class="nc" id="L1399">    int n = 0;</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">    for(int i = offset; i &lt; (offset + length); i++) {</span>
<span class="nc" id="L1401">      n &lt;&lt;= 8;</span>
<span class="nc" id="L1402">      n ^= bytes[i] &amp; 0xFF;</span>
    }
<span class="nc" id="L1404">    return n;</span>
  }

  /**
   * Converts a byte array to an int value
   * @param bytes byte array
   * @param offset offset into array
   * @param length how many bytes should be considered for creating int
   * @return the int value
   * @throws IllegalArgumentException if there's not enough room in the array at the offset
   * indicated.
   */
  public static int readAsInt(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L1417" title="All 2 branches missed.">    if (offset + length &gt; bytes.length) {</span>
<span class="nc" id="L1418">      throw new IllegalArgumentException(&quot;offset (&quot; + offset + &quot;) + length (&quot; + length</span>
          + &quot;) exceed the&quot; + &quot; capacity of the array: &quot; + bytes.length);
    }
<span class="nc" id="L1421">    int n = 0;</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">    for(int i = offset; i &lt; (offset + length); i++) {</span>
<span class="nc" id="L1423">      n &lt;&lt;= 8;</span>
<span class="nc" id="L1424">      n ^= bytes[i] &amp; 0xFF;</span>
    }
<span class="nc" id="L1426">    return n;</span>
  }

  /**
   * Put an int value out to the specified byte array position.
   * @param bytes the byte array
   * @param offset position in the array
   * @param val int to write out
   * @return incremented offset
   * @throws IllegalArgumentException if the byte array given doesn't have
   * enough room at the offset specified.
   */
  public static int putInt(byte[] bytes, int offset, int val) {
<span class="nc bnc" id="L1439" title="All 2 branches missed.">    if (bytes.length - offset &lt; SIZEOF_INT) {</span>
<span class="nc" id="L1440">      throw new IllegalArgumentException(&quot;Not enough room to put an int at&quot;</span>
          + &quot; offset &quot; + offset + &quot; in a &quot; + bytes.length + &quot; byte array&quot;);
    }
<span class="nc bnc" id="L1443" title="All 2 branches missed.">    for(int i= offset + 3; i &gt; offset; i--) {</span>
<span class="nc" id="L1444">      bytes[i] = (byte) val;</span>
<span class="nc" id="L1445">      val &gt;&gt;&gt;= 8;</span>
    }
<span class="nc" id="L1447">    bytes[offset] = (byte) val;</span>
<span class="nc" id="L1448">    return offset + SIZEOF_INT;</span>
  }

  /**
   * Convert a short value to a byte array of {@link #SIZEOF_SHORT} bytes long.
   * @param val value
   * @return the byte array
   */
  public static byte[] toBytes(short val) {
<span class="nc" id="L1457">    byte[] b = new byte[SIZEOF_SHORT];</span>
<span class="nc" id="L1458">    b[1] = (byte) val;</span>
<span class="nc" id="L1459">    val &gt;&gt;= 8;</span>
<span class="nc" id="L1460">    b[0] = (byte) val;</span>
<span class="nc" id="L1461">    return b;</span>
  }

  /**
   * Converts a byte array to a short value
   * @param bytes byte array
   * @return the short value
   */
  public static short toShort(byte[] bytes) {
<span class="nc" id="L1470">    return toShort(bytes, 0, SIZEOF_SHORT);</span>
  }

  /**
   * Converts a byte array to a short value
   * @param bytes byte array
   * @param offset offset into array
   * @return the short value
   */
  public static short toShort(byte[] bytes, int offset) {
<span class="nc" id="L1480">    return toShort(bytes, offset, SIZEOF_SHORT);</span>
  }

  /**
   * Converts a byte array to a short value
   * @param bytes byte array
   * @param offset offset into array
   * @param length length, has to be {@link #SIZEOF_SHORT}
   * @return the short value
   * @throws IllegalArgumentException if length is not {@link #SIZEOF_SHORT}
   * or if there's not enough room in the array at the offset indicated.
   */
  public static short toShort(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L1493" title="All 4 branches missed.">    if (length != SIZEOF_SHORT || offset + length &gt; bytes.length) {</span>
<span class="nc" id="L1494">      throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_SHORT);</span>
    }
<span class="nc" id="L1496">    short n = 0;</span>
<span class="nc" id="L1497">    n ^= bytes[offset] &amp; 0xFF;</span>
<span class="nc" id="L1498">    n &lt;&lt;= 8;</span>
<span class="nc" id="L1499">    n ^= bytes[offset+1] &amp; 0xFF;</span>
<span class="nc" id="L1500">    return n;</span>
  }

  /**
   * Returns a new byte array, copied from the given {@code buf},
   * from the position (inclusive) to the limit (exclusive).
   * The position and the other index parameters are not changed.
   *
   * @param buf a byte buffer
   * @return the byte array
   * @see #toBytes(ByteBuffer)
   */
  public static byte[] getBytes(ByteBuffer buf) {
<span class="nc" id="L1513">    return readBytes(buf.duplicate());</span>
  }

  /**
   * Put a short value out to the specified byte array position.
   * @param bytes the byte array
   * @param offset position in the array
   * @param val short to write out
   * @return incremented offset
   * @throws IllegalArgumentException if the byte array given doesn't have
   * enough room at the offset specified.
   */
  public static int putShort(byte[] bytes, int offset, short val) {
<span class="nc bnc" id="L1526" title="All 2 branches missed.">    if (bytes.length - offset &lt; SIZEOF_SHORT) {</span>
<span class="nc" id="L1527">      throw new IllegalArgumentException(&quot;Not enough room to put a short at&quot;</span>
          + &quot; offset &quot; + offset + &quot; in a &quot; + bytes.length + &quot; byte array&quot;);
    }
<span class="nc" id="L1530">    bytes[offset+1] = (byte) val;</span>
<span class="nc" id="L1531">    val &gt;&gt;= 8;</span>
<span class="nc" id="L1532">    bytes[offset] = (byte) val;</span>
<span class="nc" id="L1533">    return offset + SIZEOF_SHORT;</span>
  }

  /**
   * Put an int value as short out to the specified byte array position. Only the lower 2 bytes of
   * the short will be put into the array. The caller of the API need to make sure they will not
   * loose the value by doing so. This is useful to store an unsigned short which is represented as
   * int in other parts.
   * @param bytes the byte array
   * @param offset position in the array
   * @param val value to write out
   * @return incremented offset
   * @throws IllegalArgumentException if the byte array given doesn't have
   * enough room at the offset specified.
   */
  public static int putAsShort(byte[] bytes, int offset, int val) {
<span class="nc bnc" id="L1549" title="All 2 branches missed.">    if (bytes.length - offset &lt; SIZEOF_SHORT) {</span>
<span class="nc" id="L1550">      throw new IllegalArgumentException(&quot;Not enough room to put a short at&quot;</span>
          + &quot; offset &quot; + offset + &quot; in a &quot; + bytes.length + &quot; byte array&quot;);
    }
<span class="nc" id="L1553">    bytes[offset+1] = (byte) val;</span>
<span class="nc" id="L1554">    val &gt;&gt;= 8;</span>
<span class="nc" id="L1555">    bytes[offset] = (byte) val;</span>
<span class="nc" id="L1556">    return offset + SIZEOF_SHORT;</span>
  }

  /**
   * Convert a BigDecimal value to a byte array
   *
   * @param val
   * @return the byte array
   */
  public static byte[] toBytes(BigDecimal val) {
<span class="nc" id="L1566">    byte[] valueBytes = val.unscaledValue().toByteArray();</span>
<span class="nc" id="L1567">    byte[] result = new byte[valueBytes.length + SIZEOF_INT];</span>
<span class="nc" id="L1568">    int offset = putInt(result, 0, val.scale());</span>
<span class="nc" id="L1569">    putBytes(result, offset, valueBytes, 0, valueBytes.length);</span>
<span class="nc" id="L1570">    return result;</span>
  }


  /**
   * Converts a byte array to a BigDecimal
   *
   * @param bytes
   * @return the char value
   */
  public static BigDecimal toBigDecimal(byte[] bytes) {
<span class="nc" id="L1581">    return toBigDecimal(bytes, 0, bytes.length);</span>
  }

  /**
   * Converts a byte array to a BigDecimal value
   *
   * @param bytes
   * @param offset
   * @param length
   * @return the char value
   */
  public static BigDecimal toBigDecimal(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L1593" title="All 6 branches missed.">    if (bytes == null || length &lt; SIZEOF_INT + 1 ||</span>
        (offset + length &gt; bytes.length)) {
<span class="nc" id="L1595">      return null;</span>
    }

<span class="nc" id="L1598">    int scale = toInt(bytes, offset);</span>
<span class="nc" id="L1599">    byte[] tcBytes = new byte[length - SIZEOF_INT];</span>
<span class="nc" id="L1600">    System.arraycopy(bytes, offset + SIZEOF_INT, tcBytes, 0, length - SIZEOF_INT);</span>
<span class="nc" id="L1601">    return new BigDecimal(new BigInteger(tcBytes), scale);</span>
  }

  /**
   * Put a BigDecimal value out to the specified byte array position.
   *
   * @param bytes  the byte array
   * @param offset position in the array
   * @param val    BigDecimal to write out
   * @return incremented offset
   */
  public static int putBigDecimal(byte[] bytes, int offset, BigDecimal val) {
<span class="nc bnc" id="L1613" title="All 2 branches missed.">    if (bytes == null) {</span>
<span class="nc" id="L1614">      return offset;</span>
    }

<span class="nc" id="L1617">    byte[] valueBytes = val.unscaledValue().toByteArray();</span>
<span class="nc" id="L1618">    byte[] result = new byte[valueBytes.length + SIZEOF_INT];</span>
<span class="nc" id="L1619">    offset = putInt(result, offset, val.scale());</span>
<span class="nc" id="L1620">    return putBytes(result, offset, valueBytes, 0, valueBytes.length);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>