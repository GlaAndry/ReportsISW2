<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Bytes.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Apache Tajo :: Tests Coverage</a> &gt; <a href="../index.html" class="el_bundle">tajo-common</a> &gt; <a href="index.source.html" class="el_package">org.apache.tajo.util</a> &gt; <span class="el_source">Bytes.java</span></div><h1>Bytes.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.tajo.util;

import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.hadoop.classification.InterfaceAudience;
import org.apache.hadoop.classification.InterfaceStability;
import org.apache.hadoop.io.RawComparator;
import org.apache.hadoop.io.WritableComparator;
import org.apache.hadoop.io.WritableUtils;
import sun.misc.Unsafe;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import static com.google.common.base.Preconditions.*;

/**
 * Utility class that handles byte arrays, conversions to/from other types,
 * comparisons, hash code generation, manufacturing keys for HashMaps or
 * HashSets, etc.
 */
<span class="nc" id="L55">public class Bytes {</span>
  //HConstants.UTF8_ENCODING should be updated if this changed
  /** When we encode strings, we always specify UTF8 encoding */
  public static final String UTF8_ENCODING = &quot;UTF-8&quot;;

  //HConstants.UTF8_CHARSET should be updated if this changed
  /** When we encode strings, we always specify UTF8 encoding */
<span class="nc" id="L62">  public static final Charset UTF8_CHARSET = Charset.forName(UTF8_ENCODING);</span>

  //HConstants.EMPTY_BYTE_ARRAY should be updated if this changed
<span class="nc" id="L65">  public static final byte [] EMPTY_BYTE_ARRAY = new byte [0];</span>

<span class="nc" id="L67">  private static final Log LOG = LogFactory.getLog(Bytes.class);</span>

  /**
   * Size of boolean in bytes
   */
  public static final int SIZEOF_BOOLEAN = Byte.SIZE / Byte.SIZE;

  /**
   * Size of byte in bytes
   */
  public static final int SIZEOF_BYTE = SIZEOF_BOOLEAN;

  /**
   * Size of char in bytes
   */
  public static final int SIZEOF_CHAR = Character.SIZE / Byte.SIZE;

  /**
   * Size of double in bytes
   */
  public static final int SIZEOF_DOUBLE = Double.SIZE / Byte.SIZE;

  /**
   * Size of float in bytes
   */
  public static final int SIZEOF_FLOAT = Float.SIZE / Byte.SIZE;

  /**
   * Size of int in bytes
   */
  public static final int SIZEOF_INT = Integer.SIZE / Byte.SIZE;

  /**
   * Size of long in bytes
   */
  public static final int SIZEOF_LONG = Long.SIZE / Byte.SIZE;

  /**
   * Size of short in bytes
   */
  public static final int SIZEOF_SHORT = Short.SIZE / Byte.SIZE;

  /**
   * Estimate of size cost to pay beyond payload in jvm for instance of byte [].
   * Estimate based on study of jhat and jprofiler numbers.
   */
  // JHat says BU is 56 bytes.
  // SizeOf which uses java.lang.instrument says 24 bytes. (3 longs?)
  public static final int ESTIMATED_HEAP_TAX = 16;

  /**
   * Returns length of the byte array, returning 0 if the array is null.
   * Useful for calculating sizes.
   * @param b byte array, which can be null
   * @return 0 if b is null, otherwise returns length
   */
  final public static int len(byte[] b) {
<span class="nc bnc" id="L124" title="All 2 branches missed.">    return b == null ? 0 : b.length;</span>
  }

  /**
   * Byte array comparator class.
   */
  @InterfaceAudience.Public
  @InterfaceStability.Stable
  public static class ByteArrayComparator implements RawComparator&lt;byte []&gt; {
    /**
     * Constructor
     */
    public ByteArrayComparator() {
<span class="nc" id="L137">      super();</span>
<span class="nc" id="L138">    }</span>
    @Override
    public int compare(byte [] left, byte [] right) {
<span class="nc" id="L141">      return compareTo(left, right);</span>
    }
    @Override
    public int compare(byte [] b1, int s1, int l1, byte [] b2, int s2, int l2) {
<span class="nc" id="L145">      return LexicographicalComparerHolder.BEST_COMPARER.</span>
<span class="nc" id="L146">          compareTo(b1, s1, l1, b2, s2, l2);</span>
    }
  }

  /**
   * A {@link ByteArrayComparator} that treats the empty array as the largest value.
   * This is useful for comparing row end keys for regions.
   */
  // TODO: unfortunately, HBase uses byte[0] as both start and end keys for region
  // boundaries. Thus semantically, we should treat empty byte array as the smallest value
  // while comparing row keys, start keys etc; but as the largest value for comparing
  // region boundaries for endKeys.
  @InterfaceAudience.Public
  @InterfaceStability.Stable
<span class="nc" id="L160">  public static class RowEndKeyComparator extends ByteArrayComparator {</span>
    @Override
    public int compare(byte[] left, byte[] right) {
<span class="nc" id="L163">      return compare(left, 0, left.length, right, 0, right.length);</span>
    }
    @Override
    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
<span class="nc bnc" id="L167" title="All 6 branches missed.">      if (b1 == b2 &amp;&amp; s1 == s2 &amp;&amp; l1 == l2) {</span>
<span class="nc" id="L168">        return 0;</span>
      }
<span class="nc bnc" id="L170" title="All 2 branches missed.">      if (l1 == 0) {</span>
<span class="nc" id="L171">        return l2; //0 or positive</span>
      }
<span class="nc bnc" id="L173" title="All 2 branches missed.">      if (l2 == 0) {</span>
<span class="nc" id="L174">        return -1;</span>
      }
<span class="nc" id="L176">      return super.compare(b1, s1, l1, b2, s2, l2);</span>
    }
  }

  /**
   * Pass this to TreeMaps where byte [] are keys.
   */
<span class="nc" id="L183">  public final static Comparator&lt;byte []&gt; BYTES_COMPARATOR = new ByteArrayComparator();</span>

  /**
   * Use comparing byte arrays, byte-by-byte
   */
<span class="nc" id="L188">  public final static RawComparator&lt;byte []&gt; BYTES_RAWCOMPARATOR = new ByteArrayComparator();</span>

  /**
   * Read byte-array written with a WritableableUtils.vint prefix.
   * @param in Input to read from.
   * @return byte array read off &lt;code&gt;in&lt;/code&gt;
   * @throws IOException e
   */
  public static byte [] readByteArray(final DataInput in)
      throws IOException {
<span class="nc" id="L198">    int len = WritableUtils.readVInt(in);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    if (len &lt; 0) {</span>
<span class="nc" id="L200">      throw new NegativeArraySizeException(Integer.toString(len));</span>
    }
<span class="nc" id="L202">    byte [] result = new byte[len];</span>
<span class="nc" id="L203">    in.readFully(result, 0, len);</span>
<span class="nc" id="L204">    return result;</span>
  }

  /**
   * Read byte-array written with a WritableableUtils.vint prefix.
   * IOException is converted to a RuntimeException.
   * @param in Input to read from.
   * @return byte array read off &lt;code&gt;in&lt;/code&gt;
   */
  public static byte [] readByteArrayThrowsRuntime(final DataInput in) {
    try {
<span class="nc" id="L215">      return readByteArray(in);</span>
<span class="nc" id="L216">    } catch (Exception e) {</span>
<span class="nc" id="L217">      throw new RuntimeException(e);</span>
    }
  }

  /**
   * Write byte-array with a WritableableUtils.vint prefix.
   * @param out output stream to be written to
   * @param b array to write
   * @throws IOException e
   */
  public static void writeByteArray(final DataOutput out, final byte [] b)
      throws IOException {
<span class="nc bnc" id="L229" title="All 2 branches missed.">    if(b == null) {</span>
<span class="nc" id="L230">      WritableUtils.writeVInt(out, 0);</span>
    } else {
<span class="nc" id="L232">      writeByteArray(out, b, 0, b.length);</span>
    }
<span class="nc" id="L234">  }</span>

  /**
   * Write byte-array to out with a vint length prefix.
   * @param out output stream
   * @param b array
   * @param offset offset into array
   * @param length length past offset
   * @throws IOException e
   */
  public static void writeByteArray(final DataOutput out, final byte [] b,
                                    final int offset, final int length)
      throws IOException {
<span class="nc" id="L247">    WritableUtils.writeVInt(out, length);</span>
<span class="nc" id="L248">    out.write(b, offset, length);</span>
<span class="nc" id="L249">  }</span>

  /**
   * Write byte-array from src to tgt with a vint length prefix.
   * @param tgt target array
   * @param tgtOffset offset into target array
   * @param src source array
   * @param srcOffset source offset
   * @param srcLength source length
   * @return New offset in src array.
   */
  public static int writeByteArray(final byte [] tgt, final int tgtOffset,
                                   final byte [] src, final int srcOffset, final int srcLength) {
<span class="nc" id="L262">    byte [] vint = vintToBytes(srcLength);</span>
<span class="nc" id="L263">    System.arraycopy(vint, 0, tgt, tgtOffset, vint.length);</span>
<span class="nc" id="L264">    int offset = tgtOffset + vint.length;</span>
<span class="nc" id="L265">    System.arraycopy(src, srcOffset, tgt, offset, srcLength);</span>
<span class="nc" id="L266">    return offset + srcLength;</span>
  }

  /**
   * Put bytes at the specified byte array position.
   * @param tgtBytes the byte array
   * @param tgtOffset position in the array
   * @param srcBytes array to write out
   * @param srcOffset source offset
   * @param srcLength source length
   * @return incremented offset
   */
  public static int putBytes(byte[] tgtBytes, int tgtOffset, byte[] srcBytes,
                             int srcOffset, int srcLength) {
<span class="nc" id="L280">    System.arraycopy(srcBytes, srcOffset, tgtBytes, tgtOffset, srcLength);</span>
<span class="nc" id="L281">    return tgtOffset + srcLength;</span>
  }

  /**
   * Write a single byte out to the specified byte array position.
   * @param bytes the byte array
   * @param offset position in the array
   * @param b byte to write out
   * @return incremented offset
   */
  public static int putByte(byte[] bytes, int offset, byte b) {
<span class="nc" id="L292">    bytes[offset] = b;</span>
<span class="nc" id="L293">    return offset + 1;</span>
  }

  /**
   * Add the whole content of the ByteBuffer to the bytes arrays. The ByteBuffer is modified.
   * @param bytes the byte array
   * @param offset position in the array
   * @param buf ByteBuffer to write out
   * @return incremented offset
   */
  public static int putByteBuffer(byte[] bytes, int offset, ByteBuffer buf) {
<span class="nc" id="L304">    int len = buf.remaining();</span>
<span class="nc" id="L305">    buf.get(bytes, offset, len);</span>
<span class="nc" id="L306">    return offset + len;</span>
  }

  /**
   * Returns a new byte array, copied from the given {@code buf},
   * from the index 0 (inclusive) to the limit (exclusive),
   * regardless of the current position.
   * The position and the other index parameters are not changed.
   *
   * @param buf a byte buffer
   * @return the byte array
   * @see #getBytes(ByteBuffer)
   */
  public static byte[] toBytes(ByteBuffer buf) {
<span class="nc" id="L320">    ByteBuffer dup = buf.duplicate();</span>
<span class="nc" id="L321">    dup.position(0);</span>
<span class="nc" id="L322">    return readBytes(dup);</span>
  }

  private static byte[] readBytes(ByteBuffer buf) {
<span class="nc" id="L326">    byte [] result = new byte[buf.remaining()];</span>
<span class="nc" id="L327">    buf.get(result);</span>
<span class="nc" id="L328">    return result;</span>
  }

  /**
   * @param b Presumed UTF-8 encoded byte array.
   * @return String made from &lt;code&gt;b&lt;/code&gt;
   */
  public static String toString(final byte [] b) {
<span class="nc bnc" id="L336" title="All 2 branches missed.">    if (b == null) {</span>
<span class="nc" id="L337">      return null;</span>
    }
<span class="nc" id="L339">    return toString(b, 0, b.length);</span>
  }

  /**
   * Joins two byte arrays together using a separator.
   * @param b1 The first byte array.
   * @param sep The separator to use.
   * @param b2 The second byte array.
   */
  public static String toString(final byte [] b1,
                                String sep,
                                final byte [] b2) {
<span class="nc" id="L351">    return toString(b1, 0, b1.length) + sep + toString(b2, 0, b2.length);</span>
  }

  /**
   * This method will convert utf8 encoded bytes into a string. If
   * the given byte array is null, this method will return null.
   *
   * @param b Presumed UTF-8 encoded byte array.
   * @param off offset into array
   * @param len length of utf-8 sequence
   * @return String made from &lt;code&gt;b&lt;/code&gt; or null
   */
  public static String toString(final byte [] b, int off, int len) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">    if (b == null) {</span>
<span class="nc" id="L365">      return null;</span>
    }
<span class="nc bnc" id="L367" title="All 2 branches missed.">    if (len == 0) {</span>
<span class="nc" id="L368">      return &quot;&quot;;</span>
    }
<span class="nc" id="L370">    return new String(b, off, len, UTF8_CHARSET);</span>
  }

  /**
   * Write a printable representation of a byte array.
   *
   * @param b byte array
   * @return string
   * @see #toStringBinary(byte[], int, int)
   */
  public static String toStringBinary(final byte [] b) {
<span class="nc bnc" id="L381" title="All 2 branches missed.">    if (b == null)</span>
<span class="nc" id="L382">      return &quot;null&quot;;</span>
<span class="nc" id="L383">    return toStringBinary(b, 0, b.length);</span>
  }

  /**
   * Converts the given byte buffer to a printable representation,
   * from the index 0 (inclusive) to the limit (exclusive),
   * regardless of the current position.
   * The position and the other index parameters are not changed.
   *
   * @param buf a byte buffer
   * @return a string representation of the buffer's binary contents
   * @see #toBytes(ByteBuffer)
   * @see #getBytes(ByteBuffer)
   */
  public static String toStringBinary(ByteBuffer buf) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">    if (buf == null)</span>
<span class="nc" id="L399">      return &quot;null&quot;;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">    if (buf.hasArray()) {</span>
<span class="nc" id="L401">      return toStringBinary(buf.array(), buf.arrayOffset(), buf.limit());</span>
    }
<span class="nc" id="L403">    return toStringBinary(toBytes(buf));</span>
  }

  /**
   * Write a printable representation of a byte array. Non-printable
   * characters are hex escaped in the format \\x%02X, eg:
   * \x00 \x05 etc
   *
   * @param b array to write out
   * @param off offset to start at
   * @param len length to write
   * @return string output
   */
  public static String toStringBinary(final byte [] b, int off, int len) {
<span class="nc" id="L417">    StringBuilder result = new StringBuilder();</span>
    // Just in case we are passed a 'len' that is &gt; buffer length...
<span class="nc bnc" id="L419" title="All 2 branches missed.">    if (off &gt;= b.length) return result.toString();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">    if (off + len &gt; b.length) len = b.length - off;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">    for (int i = off; i &lt; off + len ; ++i ) {</span>
<span class="nc" id="L422">      int ch = b[i] &amp; 0xFF;</span>
<span class="nc bnc" id="L423" title="All 12 branches missed.">      if ( (ch &gt;= '0' &amp;&amp; ch &lt;= '9')</span>
          || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')
          || (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')
<span class="nc bnc" id="L426" title="All 2 branches missed.">          || &quot; `~!@#$%^&amp;*()-_=+[]{}|;:'\&quot;,.&lt;&gt;/?&quot;.indexOf(ch) &gt;= 0 ) {</span>
<span class="nc" id="L427">        result.append((char)ch);</span>
      } else {
<span class="nc" id="L429">        result.append(String.format(&quot;\\x%02X&quot;, ch));</span>
      }
    }
<span class="nc" id="L432">    return result.toString();</span>
  }

  private static boolean isHexDigit(char c) {
<span class="nc bnc" id="L436" title="All 8 branches missed.">    return</span>
        (c &gt;= 'A' &amp;&amp; c &lt;= 'F') ||
            (c &gt;= '0' &amp;&amp; c &lt;= '9');
  }

  /**
   * Takes a ASCII digit in the range A-F0-9 and returns
   * the corresponding integer/ordinal value.
   * @param ch  The hex digit.
   * @return The converted hex value as a byte.
   */
  public static byte toBinaryFromHex(byte ch) {
<span class="nc bnc" id="L448" title="All 4 branches missed.">    if ( ch &gt;= 'A' &amp;&amp; ch &lt;= 'F' )</span>
<span class="nc" id="L449">      return (byte) ((byte)10 + (byte) (ch - 'A'));</span>
    // else
<span class="nc" id="L451">    return (byte) (ch - '0');</span>
  }

  public static byte [] toBytesBinary(String in) {
    // this may be bigger than we need, but let's be safe.
<span class="nc" id="L456">    byte [] b = new byte[in.length()];</span>
<span class="nc" id="L457">    int size = 0;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">    for (int i = 0; i &lt; in.length(); ++i) {</span>
<span class="nc" id="L459">      char ch = in.charAt(i);</span>
<span class="nc bnc" id="L460" title="All 6 branches missed.">      if (ch == '\\' &amp;&amp; in.length() &gt; i+1 &amp;&amp; in.charAt(i+1) == 'x') {</span>
        // ok, take next 2 hex digits.
<span class="nc" id="L462">        char hd1 = in.charAt(i+2);</span>
<span class="nc" id="L463">        char hd2 = in.charAt(i+3);</span>

        // they need to be A-F0-9:
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (!isHexDigit(hd1) ||</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            !isHexDigit(hd2)) {</span>
          // bogus escape code, ignore:
<span class="nc" id="L469">          continue;</span>
        }
        // turn hex ASCII digit -&gt; number
<span class="nc" id="L472">        byte d = (byte) ((toBinaryFromHex((byte)hd1) &lt;&lt; 4) + toBinaryFromHex((byte)hd2));</span>

<span class="nc" id="L474">        b[size++] = d;</span>
<span class="nc" id="L475">        i += 3; // skip 3</span>
<span class="nc" id="L476">      } else {</span>
<span class="nc" id="L477">        b[size++] = (byte) ch;</span>
      }
    }
    // resize:
<span class="nc" id="L481">    byte [] b2 = new byte[size];</span>
<span class="nc" id="L482">    System.arraycopy(b, 0, b2, 0, size);</span>
<span class="nc" id="L483">    return b2;</span>
  }

  /**
   * Converts a string to a UTF-8 byte array.
   * @param s string
   * @return the byte array
   */
  public static byte[] toBytes(String s) {
<span class="nc" id="L492">    return s.getBytes(UTF8_CHARSET);</span>
  }

  /**
   * Convert a boolean to a byte array. True becomes -1
   * and false becomes 0.
   *
   * @param b value
   * @return &lt;code&gt;b&lt;/code&gt; encoded in a byte array.
   */
  public static byte [] toBytes(final boolean b) {
<span class="nc bnc" id="L503" title="All 2 branches missed.">    return new byte[] { b ? (byte) -1 : (byte) 0 };</span>
  }

  /**
   * Reverses {@link #toBytes(boolean)}
   * @param b array
   * @return True or false.
   */
  public static boolean toBoolean(final byte [] b) {
<span class="nc bnc" id="L512" title="All 2 branches missed.">    if (b.length != 1) {</span>
<span class="nc" id="L513">      throw new IllegalArgumentException(&quot;Array has wrong size: &quot; + b.length);</span>
    }
<span class="nc bnc" id="L515" title="All 2 branches missed.">    return b[0] != (byte) 0;</span>
  }

  /**
   * Convert a long value to a byte array using big-endian.
   *
   * @param val value to convert
   * @return the byte array
   */
  public static byte[] toBytes(long val) {
<span class="nc" id="L525">    byte [] b = new byte[8];</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">    for (int i = 7; i &gt; 0; i--) {</span>
<span class="nc" id="L527">      b[i] = (byte) val;</span>
<span class="nc" id="L528">      val &gt;&gt;&gt;= 8;</span>
    }
<span class="nc" id="L530">    b[0] = (byte) val;</span>
<span class="nc" id="L531">    return b;</span>
  }

  /**
   * Converts a byte array to a long value. Reverses
   * {@link #toBytes(long)}
   * @param bytes array
   * @return the long value
   */
  public static long toLong(byte[] bytes) {
<span class="nc" id="L541">    return toLong(bytes, 0, SIZEOF_LONG);</span>
  }

  /**
   * Converts a byte array to a long value. Assumes there will be
   * {@link #SIZEOF_LONG} bytes available.
   *
   * @param bytes bytes
   * @param offset offset
   * @return the long value
   */
  public static long toLong(byte[] bytes, int offset) {
<span class="nc" id="L553">    return toLong(bytes, offset, SIZEOF_LONG);</span>
  }

  /**
   * Converts a byte array to a long value.
   *
   * @param bytes array of bytes
   * @param offset offset into array
   * @param length length of data (must be {@link #SIZEOF_LONG})
   * @return the long value
   * @throws IllegalArgumentException if length is not {@link #SIZEOF_LONG} or
   * if there's not enough room in the array at the offset indicated.
   */
  public static long toLong(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L567" title="All 4 branches missed.">    if (length != SIZEOF_LONG || offset + length &gt; bytes.length) {</span>
<span class="nc" id="L568">      throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_LONG);</span>
    }
<span class="nc" id="L570">    long l = 0;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">    for(int i = offset; i &lt; offset + length; i++) {</span>
<span class="nc" id="L572">      l &lt;&lt;= 8;</span>
<span class="nc" id="L573">      l ^= bytes[i] &amp; 0xFF;</span>
    }
<span class="nc" id="L575">    return l;</span>
  }

  private static IllegalArgumentException
  explainWrongLengthOrOffset(final byte[] bytes,
                             final int offset,
                             final int length,
                             final int expectedLength) {
    String reason;
<span class="nc bnc" id="L584" title="All 2 branches missed.">    if (length != expectedLength) {</span>
<span class="nc" id="L585">      reason = &quot;Wrong length: &quot; + length + &quot;, expected &quot; + expectedLength;</span>
    } else {
<span class="nc" id="L587">      reason = &quot;offset (&quot; + offset + &quot;) + length (&quot; + length + &quot;) exceed the&quot;</span>
          + &quot; capacity of the array: &quot; + bytes.length;
    }
<span class="nc" id="L590">    return new IllegalArgumentException(reason);</span>
  }

  /**
   * Put a long value out to the specified byte array position.
   * @param bytes the byte array
   * @param offset position in the array
   * @param val long to write out
   * @return incremented offset
   * @throws IllegalArgumentException if the byte array given doesn't have
   * enough room at the offset specified.
   */
  public static int putLong(byte[] bytes, int offset, long val) {
<span class="nc bnc" id="L603" title="All 2 branches missed.">    if (bytes.length - offset &lt; SIZEOF_LONG) {</span>
<span class="nc" id="L604">      throw new IllegalArgumentException(&quot;Not enough room to put a long at&quot;</span>
          + &quot; offset &quot; + offset + &quot; in a &quot; + bytes.length + &quot; byte array&quot;);
    }
<span class="nc bnc" id="L607" title="All 2 branches missed.">    for(int i = offset + 7; i &gt; offset; i--) {</span>
<span class="nc" id="L608">      bytes[i] = (byte) val;</span>
<span class="nc" id="L609">      val &gt;&gt;&gt;= 8;</span>
    }
<span class="nc" id="L611">    bytes[offset] = (byte) val;</span>
<span class="nc" id="L612">    return offset + SIZEOF_LONG;</span>
  }

  /**
   * Presumes float encoded as IEEE 754 floating-point &quot;single format&quot;
   * @param bytes byte array
   * @return Float made from passed byte array.
   */
  public static float toFloat(byte [] bytes) {
<span class="nc" id="L621">    return toFloat(bytes, 0);</span>
  }

  /**
   * Presumes float encoded as IEEE 754 floating-point &quot;single format&quot;
   * @param bytes array to convert
   * @param offset offset into array
   * @return Float made from passed byte array.
   */
  public static float toFloat(byte [] bytes, int offset) {
<span class="nc" id="L631">    return Float.intBitsToFloat(toInt(bytes, offset, SIZEOF_INT));</span>
  }

  /**
   * @param bytes byte array
   * @param offset offset to write to
   * @param f float value
   * @return New offset in &lt;code&gt;bytes&lt;/code&gt;
   */
  public static int putFloat(byte [] bytes, int offset, float f) {
<span class="nc" id="L641">    return putInt(bytes, offset, Float.floatToRawIntBits(f));</span>
  }

  /**
   * @param f float value
   * @return the float represented as byte []
   */
  public static byte [] toBytes(final float f) {
    // Encode it as int
<span class="nc" id="L650">    return Bytes.toBytes(Float.floatToRawIntBits(f));</span>
  }

  /**
   * @param bytes byte array
   * @return Return double made from passed bytes.
   */
  public static double toDouble(final byte [] bytes) {
<span class="nc" id="L658">    return toDouble(bytes, 0);</span>
  }

  /**
   * @param bytes byte array
   * @param offset offset where double is
   * @return Return double made from passed bytes.
   */
  public static double toDouble(final byte [] bytes, final int offset) {
<span class="nc" id="L667">    return Double.longBitsToDouble(toLong(bytes, offset, SIZEOF_LONG));</span>
  }

  /**
   * @param bytes byte array
   * @param offset offset to write to
   * @param d value
   * @return New offset into array &lt;code&gt;bytes&lt;/code&gt;
   */
  public static int putDouble(byte [] bytes, int offset, double d) {
<span class="nc" id="L677">    return putLong(bytes, offset, Double.doubleToLongBits(d));</span>
  }

  /**
   * Serialize a double as the IEEE 754 double format output. The resultant
   * array will be 8 bytes long.
   *
   * @param d value
   * @return the double represented as byte []
   */
  public static byte [] toBytes(final double d) {
    // Encode it as a long
<span class="nc" id="L689">    return Bytes.toBytes(Double.doubleToRawLongBits(d));</span>
  }

  /**
   * Convert an int value to a byte array.  Big-endian.  Same as what DataOutputStream.writeInt
   * does.
   *
   * @param val value
   * @return the byte array
   */
  public static byte[] toBytes(int val) {
<span class="nc" id="L700">    byte [] b = new byte[4];</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">    for(int i = 3; i &gt; 0; i--) {</span>
<span class="nc" id="L702">      b[i] = (byte) val;</span>
<span class="nc" id="L703">      val &gt;&gt;&gt;= 8;</span>
    }
<span class="nc" id="L705">    b[0] = (byte) val;</span>
<span class="nc" id="L706">    return b;</span>
  }

  /**
   * Converts a byte array to an int value
   * @param bytes byte array
   * @return the int value
   */
  public static int toInt(byte[] bytes) {
<span class="nc" id="L715">    return toInt(bytes, 0, SIZEOF_INT);</span>
  }

  /**
   * Converts a byte array to an int value
   * @param bytes byte array
   * @param offset offset into array
   * @return the int value
   */
  public static int toInt(byte[] bytes, int offset) {
<span class="nc" id="L725">    return toInt(bytes, offset, SIZEOF_INT);</span>
  }

  /**
   * Converts a byte array to an int value
   * @param bytes byte array
   * @param offset offset into array
   * @param length length of int (has to be {@link #SIZEOF_INT})
   * @return the int value
   * @throws IllegalArgumentException if length is not {@link #SIZEOF_INT} or
   * if there's not enough room in the array at the offset indicated.
   */
  public static int toInt(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L738" title="All 4 branches missed.">    if (length != SIZEOF_INT || offset + length &gt; bytes.length) {</span>
<span class="nc" id="L739">      throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_INT);</span>
    }
<span class="nc" id="L741">    int n = 0;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">    for(int i = offset; i &lt; (offset + length); i++) {</span>
<span class="nc" id="L743">      n &lt;&lt;= 8;</span>
<span class="nc" id="L744">      n ^= bytes[i] &amp; 0xFF;</span>
    }
<span class="nc" id="L746">    return n;</span>
  }

  /**
   * Converts a byte array to an int value
   * @param bytes byte array
   * @param offset offset into array
   * @param length how many bytes should be considered for creating int
   * @return the int value
   * @throws IllegalArgumentException if there's not enough room in the array at the offset
   * indicated.
   */
  public static int readAsInt(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L759" title="All 2 branches missed.">    if (offset + length &gt; bytes.length) {</span>
<span class="nc" id="L760">      throw new IllegalArgumentException(&quot;offset (&quot; + offset + &quot;) + length (&quot; + length</span>
          + &quot;) exceed the&quot; + &quot; capacity of the array: &quot; + bytes.length);
    }
<span class="nc" id="L763">    int n = 0;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">    for(int i = offset; i &lt; (offset + length); i++) {</span>
<span class="nc" id="L765">      n &lt;&lt;= 8;</span>
<span class="nc" id="L766">      n ^= bytes[i] &amp; 0xFF;</span>
    }
<span class="nc" id="L768">    return n;</span>
  }

  /**
   * Put an int value out to the specified byte array position.
   * @param bytes the byte array
   * @param offset position in the array
   * @param val int to write out
   * @return incremented offset
   * @throws IllegalArgumentException if the byte array given doesn't have
   * enough room at the offset specified.
   */
  public static int putInt(byte[] bytes, int offset, int val) {
<span class="nc bnc" id="L781" title="All 2 branches missed.">    if (bytes.length - offset &lt; SIZEOF_INT) {</span>
<span class="nc" id="L782">      throw new IllegalArgumentException(&quot;Not enough room to put an int at&quot;</span>
          + &quot; offset &quot; + offset + &quot; in a &quot; + bytes.length + &quot; byte array&quot;);
    }
<span class="nc bnc" id="L785" title="All 2 branches missed.">    for(int i= offset + 3; i &gt; offset; i--) {</span>
<span class="nc" id="L786">      bytes[i] = (byte) val;</span>
<span class="nc" id="L787">      val &gt;&gt;&gt;= 8;</span>
    }
<span class="nc" id="L789">    bytes[offset] = (byte) val;</span>
<span class="nc" id="L790">    return offset + SIZEOF_INT;</span>
  }

  /**
   * Convert a short value to a byte array of {@link #SIZEOF_SHORT} bytes long.
   * @param val value
   * @return the byte array
   */
  public static byte[] toBytes(short val) {
<span class="nc" id="L799">    byte[] b = new byte[SIZEOF_SHORT];</span>
<span class="nc" id="L800">    b[1] = (byte) val;</span>
<span class="nc" id="L801">    val &gt;&gt;= 8;</span>
<span class="nc" id="L802">    b[0] = (byte) val;</span>
<span class="nc" id="L803">    return b;</span>
  }

  /**
   * Converts a byte array to a short value
   * @param bytes byte array
   * @return the short value
   */
  public static short toShort(byte[] bytes) {
<span class="nc" id="L812">    return toShort(bytes, 0, SIZEOF_SHORT);</span>
  }

  /**
   * Converts a byte array to a short value
   * @param bytes byte array
   * @param offset offset into array
   * @return the short value
   */
  public static short toShort(byte[] bytes, int offset) {
<span class="nc" id="L822">    return toShort(bytes, offset, SIZEOF_SHORT);</span>
  }

  /**
   * Converts a byte array to a short value
   * @param bytes byte array
   * @param offset offset into array
   * @param length length, has to be {@link #SIZEOF_SHORT}
   * @return the short value
   * @throws IllegalArgumentException if length is not {@link #SIZEOF_SHORT}
   * or if there's not enough room in the array at the offset indicated.
   */
  public static short toShort(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L835" title="All 4 branches missed.">    if (length != SIZEOF_SHORT || offset + length &gt; bytes.length) {</span>
<span class="nc" id="L836">      throw explainWrongLengthOrOffset(bytes, offset, length, SIZEOF_SHORT);</span>
    }
<span class="nc" id="L838">    short n = 0;</span>
<span class="nc" id="L839">    n ^= bytes[offset] &amp; 0xFF;</span>
<span class="nc" id="L840">    n &lt;&lt;= 8;</span>
<span class="nc" id="L841">    n ^= bytes[offset+1] &amp; 0xFF;</span>
<span class="nc" id="L842">    return n;</span>
  }

  /**
   * Returns a new byte array, copied from the given {@code buf},
   * from the position (inclusive) to the limit (exclusive).
   * The position and the other index parameters are not changed.
   *
   * @param buf a byte buffer
   * @return the byte array
   * @see #toBytes(ByteBuffer)
   */
  public static byte[] getBytes(ByteBuffer buf) {
<span class="nc" id="L855">    return readBytes(buf.duplicate());</span>
  }

  /**
   * Put a short value out to the specified byte array position.
   * @param bytes the byte array
   * @param offset position in the array
   * @param val short to write out
   * @return incremented offset
   * @throws IllegalArgumentException if the byte array given doesn't have
   * enough room at the offset specified.
   */
  public static int putShort(byte[] bytes, int offset, short val) {
<span class="nc bnc" id="L868" title="All 2 branches missed.">    if (bytes.length - offset &lt; SIZEOF_SHORT) {</span>
<span class="nc" id="L869">      throw new IllegalArgumentException(&quot;Not enough room to put a short at&quot;</span>
          + &quot; offset &quot; + offset + &quot; in a &quot; + bytes.length + &quot; byte array&quot;);
    }
<span class="nc" id="L872">    bytes[offset+1] = (byte) val;</span>
<span class="nc" id="L873">    val &gt;&gt;= 8;</span>
<span class="nc" id="L874">    bytes[offset] = (byte) val;</span>
<span class="nc" id="L875">    return offset + SIZEOF_SHORT;</span>
  }

  /**
   * Put an int value as short out to the specified byte array position. Only the lower 2 bytes of
   * the short will be put into the array. The caller of the API need to make sure they will not
   * loose the value by doing so. This is useful to store an unsigned short which is represented as
   * int in other parts.
   * @param bytes the byte array
   * @param offset position in the array
   * @param val value to write out
   * @return incremented offset
   * @throws IllegalArgumentException if the byte array given doesn't have
   * enough room at the offset specified.
   */
  public static int putAsShort(byte[] bytes, int offset, int val) {
<span class="nc bnc" id="L891" title="All 2 branches missed.">    if (bytes.length - offset &lt; SIZEOF_SHORT) {</span>
<span class="nc" id="L892">      throw new IllegalArgumentException(&quot;Not enough room to put a short at&quot;</span>
          + &quot; offset &quot; + offset + &quot; in a &quot; + bytes.length + &quot; byte array&quot;);
    }
<span class="nc" id="L895">    bytes[offset+1] = (byte) val;</span>
<span class="nc" id="L896">    val &gt;&gt;= 8;</span>
<span class="nc" id="L897">    bytes[offset] = (byte) val;</span>
<span class="nc" id="L898">    return offset + SIZEOF_SHORT;</span>
  }

  /**
   * Convert a BigDecimal value to a byte array
   *
   * @param val
   * @return the byte array
   */
  public static byte[] toBytes(BigDecimal val) {
<span class="nc" id="L908">    byte[] valueBytes = val.unscaledValue().toByteArray();</span>
<span class="nc" id="L909">    byte[] result = new byte[valueBytes.length + SIZEOF_INT];</span>
<span class="nc" id="L910">    int offset = putInt(result, 0, val.scale());</span>
<span class="nc" id="L911">    putBytes(result, offset, valueBytes, 0, valueBytes.length);</span>
<span class="nc" id="L912">    return result;</span>
  }


  /**
   * Converts a byte array to a BigDecimal
   *
   * @param bytes
   * @return the char value
   */
  public static BigDecimal toBigDecimal(byte[] bytes) {
<span class="nc" id="L923">    return toBigDecimal(bytes, 0, bytes.length);</span>
  }

  /**
   * Converts a byte array to a BigDecimal value
   *
   * @param bytes
   * @param offset
   * @param length
   * @return the char value
   */
  public static BigDecimal toBigDecimal(byte[] bytes, int offset, final int length) {
<span class="nc bnc" id="L935" title="All 6 branches missed.">    if (bytes == null || length &lt; SIZEOF_INT + 1 ||</span>
        (offset + length &gt; bytes.length)) {
<span class="nc" id="L937">      return null;</span>
    }

<span class="nc" id="L940">    int scale = toInt(bytes, offset);</span>
<span class="nc" id="L941">    byte[] tcBytes = new byte[length - SIZEOF_INT];</span>
<span class="nc" id="L942">    System.arraycopy(bytes, offset + SIZEOF_INT, tcBytes, 0, length - SIZEOF_INT);</span>
<span class="nc" id="L943">    return new BigDecimal(new BigInteger(tcBytes), scale);</span>
  }

  /**
   * Put a BigDecimal value out to the specified byte array position.
   *
   * @param bytes  the byte array
   * @param offset position in the array
   * @param val    BigDecimal to write out
   * @return incremented offset
   */
  public static int putBigDecimal(byte[] bytes, int offset, BigDecimal val) {
<span class="nc bnc" id="L955" title="All 2 branches missed.">    if (bytes == null) {</span>
<span class="nc" id="L956">      return offset;</span>
    }

<span class="nc" id="L959">    byte[] valueBytes = val.unscaledValue().toByteArray();</span>
<span class="nc" id="L960">    byte[] result = new byte[valueBytes.length + SIZEOF_INT];</span>
<span class="nc" id="L961">    offset = putInt(result, offset, val.scale());</span>
<span class="nc" id="L962">    return putBytes(result, offset, valueBytes, 0, valueBytes.length);</span>
  }

  /**
   * @param vint Integer to make a vint of.
   * @return Vint as bytes array.
   */
  public static byte [] vintToBytes(final long vint) {
<span class="nc" id="L970">    long i = vint;</span>
<span class="nc" id="L971">    int size = WritableUtils.getVIntSize(i);</span>
<span class="nc" id="L972">    byte [] result = new byte[size];</span>
<span class="nc" id="L973">    int offset = 0;</span>
<span class="nc bnc" id="L974" title="All 4 branches missed.">    if (i &gt;= -112 &amp;&amp; i &lt;= 127) {</span>
<span class="nc" id="L975">      result[offset] = (byte) i;</span>
<span class="nc" id="L976">      return result;</span>
    }

<span class="nc" id="L979">    int len = -112;</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">    if (i &lt; 0) {</span>
<span class="nc" id="L981">      i ^= -1L; // take one's complement'</span>
<span class="nc" id="L982">      len = -120;</span>
    }

<span class="nc" id="L985">    long tmp = i;</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">    while (tmp != 0) {</span>
<span class="nc" id="L987">      tmp = tmp &gt;&gt; 8;</span>
<span class="nc" id="L988">      len--;</span>
    }

<span class="nc" id="L991">    result[offset++] = (byte) len;</span>

<span class="nc bnc" id="L993" title="All 2 branches missed.">    len = (len &lt; -120) ? -(len + 120) : -(len + 112);</span>

<span class="nc bnc" id="L995" title="All 2 branches missed.">    for (int idx = len; idx != 0; idx--) {</span>
<span class="nc" id="L996">      int shiftbits = (idx - 1) * 8;</span>
<span class="nc" id="L997">      long mask = 0xFFL &lt;&lt; shiftbits;</span>
<span class="nc" id="L998">      result[offset++] = (byte)((i &amp; mask) &gt;&gt; shiftbits);</span>
    }
<span class="nc" id="L1000">    return result;</span>
  }

  /**
   * @param buffer buffer to convert
   * @return vint bytes as an integer.
   */
  public static long bytesToVint(final byte [] buffer) {
<span class="nc" id="L1008">    int offset = 0;</span>
<span class="nc" id="L1009">    byte firstByte = buffer[offset++];</span>
<span class="nc" id="L1010">    int len = WritableUtils.decodeVIntSize(firstByte);</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">    if (len == 1) {</span>
<span class="nc" id="L1012">      return firstByte;</span>
    }
<span class="nc" id="L1014">    long i = 0;</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">    for (int idx = 0; idx &lt; len-1; idx++) {</span>
<span class="nc" id="L1016">      byte b = buffer[offset++];</span>
<span class="nc" id="L1017">      i = i &lt;&lt; 8;</span>
<span class="nc" id="L1018">      i = i | (b &amp; 0xFF);</span>
    }
<span class="nc bnc" id="L1020" title="All 2 branches missed.">    return (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);</span>
  }

  /**
   * Reads a zero-compressed encoded long from input stream and returns it.
   * @param buffer Binary array
   * @param offset Offset into array at which vint begins.
   * @throws java.io.IOException e
   * @return deserialized long from stream.
   */
  public static long readVLong(final byte [] buffer, final int offset)
      throws IOException {
<span class="nc" id="L1032">    byte firstByte = buffer[offset];</span>
<span class="nc" id="L1033">    int len = WritableUtils.decodeVIntSize(firstByte);</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">    if (len == 1) {</span>
<span class="nc" id="L1035">      return firstByte;</span>
    }
<span class="nc" id="L1037">    long i = 0;</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">    for (int idx = 0; idx &lt; len-1; idx++) {</span>
<span class="nc" id="L1039">      byte b = buffer[offset + 1 + idx];</span>
<span class="nc" id="L1040">      i = i &lt;&lt; 8;</span>
<span class="nc" id="L1041">      i = i | (b &amp; 0xFF);</span>
    }
<span class="nc bnc" id="L1043" title="All 2 branches missed.">    return (WritableUtils.isNegativeVInt(firstByte) ? ~i : i);</span>
  }

  /**
   * @param left left operand
   * @param right right operand
   * @return 0 if equal, &lt; 0 if left is less than right, etc.
   */
  public static int compareTo(final byte [] left, final byte [] right) {
<span class="nc" id="L1052">    return LexicographicalComparerHolder.BEST_COMPARER.</span>
<span class="nc" id="L1053">        compareTo(left, 0, left.length, right, 0, right.length);</span>
  }

  /**
   * Lexicographically compare two arrays.
   *
   * @param buffer1 left operand
   * @param buffer2 right operand
   * @param offset1 Where to start comparing in the left buffer
   * @param offset2 Where to start comparing in the right buffer
   * @param length1 How much to compare from the left buffer
   * @param length2 How much to compare from the right buffer
   * @return 0 if equal, &lt; 0 if left is less than right, etc.
   */
  public static int compareTo(byte[] buffer1, int offset1, int length1,
                              byte[] buffer2, int offset2, int length2) {
<span class="nc" id="L1069">    return LexicographicalComparerHolder.BEST_COMPARER.</span>
<span class="nc" id="L1070">        compareTo(buffer1, offset1, length1, buffer2, offset2, length2);</span>
  }

  interface Comparer&lt;T&gt; {
    int compareTo(
        T buffer1, int offset1, int length1, T buffer2, int offset2, int length2
    );
  }

  @VisibleForTesting
  static Comparer&lt;byte[]&gt; lexicographicalComparerJavaImpl() {
<span class="nc" id="L1081">    return LexicographicalComparerHolder.PureJavaComparer.INSTANCE;</span>
  }

  /**
   * Provides a lexicographical comparer implementation; either a Java
   * implementation or a faster implementation based on {@link Unsafe}.
   *
   * &lt;p&gt;Uses reflection to gracefully fall back to the Java implementation if
   * {@code Unsafe} isn't available.
   */
  @VisibleForTesting
<span class="nc" id="L1092">  static class LexicographicalComparerHolder {</span>
<span class="nc" id="L1093">    static final String UNSAFE_COMPARER_NAME =</span>
<span class="nc" id="L1094">        LexicographicalComparerHolder.class.getName() + &quot;$UnsafeComparer&quot;;</span>

<span class="nc" id="L1096">    static final Comparer&lt;byte[]&gt; BEST_COMPARER = getBestComparer();</span>
    /**
     * Returns the Unsafe-using Comparer, or falls back to the pure-Java
     * implementation if unable to do so.
     */
    static Comparer&lt;byte[]&gt; getBestComparer() {
      try {
<span class="nc" id="L1103">        Class&lt;?&gt; theClass = Class.forName(UNSAFE_COMPARER_NAME);</span>

        // yes, UnsafeComparer does implement Comparer&lt;byte[]&gt;
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1107">        Comparer&lt;byte[]&gt; comparer =</span>
<span class="nc" id="L1108">            (Comparer&lt;byte[]&gt;) theClass.getEnumConstants()[0];</span>
<span class="nc" id="L1109">        return comparer;</span>
<span class="nc" id="L1110">      } catch (Throwable t) { // ensure we really catch *everything*</span>
<span class="nc" id="L1111">        return lexicographicalComparerJavaImpl();</span>
      }
    }

<span class="nc" id="L1115">    enum PureJavaComparer implements Comparer&lt;byte[]&gt; {</span>
<span class="nc" id="L1116">      INSTANCE;</span>

      @Override
      public int compareTo(byte[] buffer1, int offset1, int length1,
                           byte[] buffer2, int offset2, int length2) {
        // Short circuit equal case
<span class="nc bnc" id="L1122" title="All 6 branches missed.">        if (buffer1 == buffer2 &amp;&amp;</span>
            offset1 == offset2 &amp;&amp;
            length1 == length2) {
<span class="nc" id="L1125">          return 0;</span>
        }
        // Bring WritableComparator code local
<span class="nc" id="L1128">        int end1 = offset1 + length1;</span>
<span class="nc" id="L1129">        int end2 = offset2 + length2;</span>
<span class="nc bnc" id="L1130" title="All 4 branches missed.">        for (int i = offset1, j = offset2; i &lt; end1 &amp;&amp; j &lt; end2; i++, j++) {</span>
<span class="nc" id="L1131">          int a = (buffer1[i] &amp; 0xff);</span>
<span class="nc" id="L1132">          int b = (buffer2[j] &amp; 0xff);</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">          if (a != b) {</span>
<span class="nc" id="L1134">            return a - b;</span>
          }
        }
<span class="nc" id="L1137">        return length1 - length2;</span>
      }
    }

<span class="nc" id="L1141">    @VisibleForTesting</span>
    enum UnsafeComparer implements Comparer&lt;byte[]&gt; {
<span class="nc" id="L1143">      INSTANCE;</span>

      static final Unsafe theUnsafe;

      /** The offset to the first element in a byte array. */
      static final int BYTE_ARRAY_BASE_OFFSET;

      static {
<span class="nc" id="L1151">        theUnsafe = (Unsafe) AccessController.doPrivileged(</span>
<span class="nc" id="L1152">            new PrivilegedAction&lt;Object&gt;() {</span>
              @Override
              public Object run() {
                try {
<span class="nc" id="L1156">                  Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span>
<span class="nc" id="L1157">                  f.setAccessible(true);</span>
<span class="nc" id="L1158">                  return f.get(null);</span>
<span class="nc" id="L1159">                } catch (NoSuchFieldException e) {</span>
                  // It doesn't matter what we throw;
                  // it's swallowed in getBestComparer().
<span class="nc" id="L1162">                  throw new Error();</span>
<span class="nc" id="L1163">                } catch (IllegalAccessException e) {</span>
<span class="nc" id="L1164">                  throw new Error();</span>
                }
              }
            });

<span class="nc" id="L1169">        BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);</span>

        // sanity check - this should never fail
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if (theUnsafe.arrayIndexScale(byte[].class) != 1) {</span>
<span class="nc" id="L1173">          throw new AssertionError();</span>
        }
      }

<span class="nc" id="L1177">      static final boolean littleEndian =</span>
<span class="nc" id="L1178">          ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN);</span>

      /**
       * Returns true if x1 is less than x2, when both values are treated as
       * unsigned.
       */
      static boolean lessThanUnsigned(long x1, long x2) {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">        return (x1 + Long.MIN_VALUE) &lt; (x2 + Long.MIN_VALUE);</span>
      }

      /**
       * Lexicographically compare two arrays.
       *
       * @param buffer1 left operand
       * @param buffer2 right operand
       * @param offset1 Where to start comparing in the left buffer
       * @param offset2 Where to start comparing in the right buffer
       * @param length1 How much to compare from the left buffer
       * @param length2 How much to compare from the right buffer
       * @return 0 if equal, &lt; 0 if left is less than right, etc.
       */
      @Override
      public int compareTo(byte[] buffer1, int offset1, int length1,
                           byte[] buffer2, int offset2, int length2) {
        // Short circuit equal case
<span class="nc bnc" id="L1203" title="All 6 branches missed.">        if (buffer1 == buffer2 &amp;&amp;</span>
            offset1 == offset2 &amp;&amp;
            length1 == length2) {
<span class="nc" id="L1206">          return 0;</span>
        }
<span class="nc" id="L1208">        int minLength = Math.min(length1, length2);</span>
<span class="nc" id="L1209">        int minWords = minLength / SIZEOF_LONG;</span>
<span class="nc" id="L1210">        int offset1Adj = offset1 + BYTE_ARRAY_BASE_OFFSET;</span>
<span class="nc" id="L1211">        int offset2Adj = offset2 + BYTE_ARRAY_BASE_OFFSET;</span>

        /*
         * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a
         * time is no slower than comparing 4 bytes at a time even on 32-bit.
         * On the other hand, it is substantially faster on 64-bit.
         */
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        for (int i = 0; i &lt; minWords * SIZEOF_LONG; i += SIZEOF_LONG) {</span>
<span class="nc" id="L1219">          long lw = theUnsafe.getLong(buffer1, offset1Adj + (long) i);</span>
<span class="nc" id="L1220">          long rw = theUnsafe.getLong(buffer2, offset2Adj + (long) i);</span>
<span class="nc" id="L1221">          long diff = lw ^ rw;</span>

<span class="nc bnc" id="L1223" title="All 2 branches missed.">          if (diff != 0) {</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">            if (!littleEndian) {</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">              return lessThanUnsigned(lw, rw) ? -1 : 1;</span>
            }

            // Use binary search
<span class="nc" id="L1229">            int n = 0;</span>
            int y;
<span class="nc" id="L1231">            int x = (int) diff;</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">            if (x == 0) {</span>
<span class="nc" id="L1233">              x = (int) (diff &gt;&gt;&gt; 32);</span>
<span class="nc" id="L1234">              n = 32;</span>
            }

<span class="nc" id="L1237">            y = x &lt;&lt; 16;</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">            if (y == 0) {</span>
<span class="nc" id="L1239">              n += 16;</span>
            } else {
<span class="nc" id="L1241">              x = y;</span>
            }

<span class="nc" id="L1244">            y = x &lt;&lt; 8;</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            if (y == 0) {</span>
<span class="nc" id="L1246">              n += 8;</span>
            }
<span class="nc" id="L1248">            return (int) (((lw &gt;&gt;&gt; n) &amp; 0xFFL) - ((rw &gt;&gt;&gt; n) &amp; 0xFFL));</span>
          }
        }

        // The epilogue to cover the last (minLength % 8) elements.
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        for (int i = minWords * SIZEOF_LONG; i &lt; minLength; i++) {</span>
<span class="nc" id="L1254">          int a = (buffer1[offset1 + i] &amp; 0xff);</span>
<span class="nc" id="L1255">          int b = (buffer2[offset2 + i] &amp; 0xff);</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">          if (a != b) {</span>
<span class="nc" id="L1257">            return a - b;</span>
          }
        }
<span class="nc" id="L1260">        return length1 - length2;</span>
      }
    }
  }

  /**
   * @param left left operand
   * @param right right operand
   * @return True if equal
   */
  public static boolean equals(final byte [] left, final byte [] right) {
    // Could use Arrays.equals?
    //noinspection SimplifiableConditionalExpression
<span class="nc bnc" id="L1273" title="All 2 branches missed.">    if (left == right) return true;</span>
<span class="nc bnc" id="L1274" title="All 4 branches missed.">    if (left == null || right == null) return false;</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">    if (left.length != right.length) return false;</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">    if (left.length == 0) return true;</span>

    // Since we're often comparing adjacent sorted data,
    // it's usual to have equal arrays except for the very last byte
    // so check that first
<span class="nc bnc" id="L1281" title="All 2 branches missed.">    if (left[left.length - 1] != right[right.length - 1]) return false;</span>

<span class="nc bnc" id="L1283" title="All 2 branches missed.">    return compareTo(left, right) == 0;</span>
  }

  public static boolean equals(final byte[] left, int leftOffset, int leftLen,
                               final byte[] right, int rightOffset, int rightLen) {
    // short circuit case
<span class="nc bnc" id="L1289" title="All 6 branches missed.">    if (left == right &amp;&amp;</span>
        leftOffset == rightOffset &amp;&amp;
        leftLen == rightLen) {
<span class="nc" id="L1292">      return true;</span>
    }
    // different lengths fast check
<span class="nc bnc" id="L1295" title="All 2 branches missed.">    if (leftLen != rightLen) {</span>
<span class="nc" id="L1296">      return false;</span>
    }
<span class="nc bnc" id="L1298" title="All 2 branches missed.">    if (leftLen == 0) {</span>
<span class="nc" id="L1299">      return true;</span>
    }

    // Since we're often comparing adjacent sorted data,
    // it's usual to have equal arrays except for the very last byte
    // so check that first
<span class="nc bnc" id="L1305" title="All 2 branches missed.">    if (left[leftOffset + leftLen - 1] != right[rightOffset + rightLen - 1]) return false;</span>

<span class="nc" id="L1307">    return LexicographicalComparerHolder.BEST_COMPARER.</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">        compareTo(left, leftOffset, leftLen, right, rightOffset, rightLen) == 0;</span>
  }


  /**
   * @param a left operand
   * @param buf right operand
   * @return True if equal
   */
  public static boolean equals(byte[] a, ByteBuffer buf) {
<span class="nc bnc" id="L1318" title="All 4 branches missed.">    if (a == null) return buf == null;</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">    if (buf == null) return false;</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">    if (a.length != buf.remaining()) return false;</span>

    // Thou shalt not modify the original byte buffer in what should be read only operations.
<span class="nc" id="L1323">    ByteBuffer b = buf.duplicate();</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">    for (byte anA : a) {</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">      if (anA != b.get()) {</span>
<span class="nc" id="L1326">        return false;</span>
      }
    }
<span class="nc" id="L1329">    return true;</span>
  }


  /**
   * Return true if the byte array on the right is a prefix of the byte
   * array on the left.
   */
  public static boolean startsWith(byte[] bytes, byte[] prefix) {
<span class="nc bnc" id="L1338" title="All 6 branches missed.">    return bytes != null &amp;&amp; prefix != null &amp;&amp;</span>
        bytes.length &gt;= prefix.length &amp;&amp;
        LexicographicalComparerHolder.BEST_COMPARER.
<span class="nc bnc" id="L1341" title="All 2 branches missed.">            compareTo(bytes, 0, prefix.length, prefix, 0, prefix.length) == 0;</span>
  }

  /**
   * @param b bytes to hash
   * @return Runs {@link WritableComparator#hashBytes(byte[], int)} on the
   * passed in array.  This method is what {@link org.apache.hadoop.io.Text} and
   * {@link ImmutableBytesWritable} use calculating hash code.
   */
  public static int hashCode(final byte [] b) {
<span class="nc" id="L1351">    return hashCode(b, b.length);</span>
  }

  /**
   * @param b value
   * @param length length of the value
   * @return Runs {@link WritableComparator#hashBytes(byte[], int)} on the
   * passed in array.  This method is what {@link org.apache.hadoop.io.Text} and
   * {@link ImmutableBytesWritable} use calculating hash code.
   */
  public static int hashCode(final byte [] b, final int length) {
<span class="nc" id="L1362">    return WritableComparator.hashBytes(b, length);</span>
  }

  /**
   * @param b bytes to hash
   * @return A hash of &lt;code&gt;b&lt;/code&gt; as an Integer that can be used as key in
   * Maps.
   */
  public static Integer mapKey(final byte [] b) {
<span class="nc" id="L1371">    return hashCode(b);</span>
  }

  /**
   * @param b bytes to hash
   * @param length length to hash
   * @return A hash of &lt;code&gt;b&lt;/code&gt; as an Integer that can be used as key in
   * Maps.
   */
  public static Integer mapKey(final byte [] b, final int length) {
<span class="nc" id="L1381">    return hashCode(b, length);</span>
  }

  /**
   * @param a lower half
   * @param b upper half
   * @return New array that has a in lower half and b in upper half.
   */
  public static byte [] add(final byte [] a, final byte [] b) {
<span class="nc" id="L1390">    return add(a, b, EMPTY_BYTE_ARRAY);</span>
  }

  /**
   * @param a first third
   * @param b second third
   * @param c third third
   * @return New array made from a, b and c
   */
  public static byte [] add(final byte [] a, final byte [] b, final byte [] c) {
<span class="nc" id="L1400">    byte [] result = new byte[a.length + b.length + c.length];</span>
<span class="nc" id="L1401">    System.arraycopy(a, 0, result, 0, a.length);</span>
<span class="nc" id="L1402">    System.arraycopy(b, 0, result, a.length, b.length);</span>
<span class="nc" id="L1403">    System.arraycopy(c, 0, result, a.length + b.length, c.length);</span>
<span class="nc" id="L1404">    return result;</span>
  }

  /**
   * @param a array
   * @param length amount of bytes to grab
   * @return First &lt;code&gt;length&lt;/code&gt; bytes from &lt;code&gt;a&lt;/code&gt;
   */
  public static byte [] head(final byte [] a, final int length) {
<span class="nc bnc" id="L1413" title="All 2 branches missed.">    if (a.length &lt; length) {</span>
<span class="nc" id="L1414">      return null;</span>
    }
<span class="nc" id="L1416">    byte [] result = new byte[length];</span>
<span class="nc" id="L1417">    System.arraycopy(a, 0, result, 0, length);</span>
<span class="nc" id="L1418">    return result;</span>
  }

  /**
   * @param a array
   * @param length amount of bytes to snarf
   * @return Last &lt;code&gt;length&lt;/code&gt; bytes from &lt;code&gt;a&lt;/code&gt;
   */
  public static byte [] tail(final byte [] a, final int length) {
<span class="nc bnc" id="L1427" title="All 2 branches missed.">    if (a.length &lt; length) {</span>
<span class="nc" id="L1428">      return null;</span>
    }
<span class="nc" id="L1430">    byte [] result = new byte[length];</span>
<span class="nc" id="L1431">    System.arraycopy(a, a.length - length, result, 0, length);</span>
<span class="nc" id="L1432">    return result;</span>
  }

  /**
   * @param a array
   * @param length new array size
   * @return Value in &lt;code&gt;a&lt;/code&gt; plus &lt;code&gt;length&lt;/code&gt; prepended 0 bytes
   */
  public static byte [] padHead(final byte [] a, final int length) {
<span class="nc" id="L1441">    byte [] padding = new byte[length];</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L1443">      padding[i] = 0;</span>
    }
<span class="nc" id="L1445">    return add(padding,a);</span>
  }

  /**
   * @param a array
   * @param length new array size
   * @return Value in &lt;code&gt;a&lt;/code&gt; plus &lt;code&gt;length&lt;/code&gt; appended 0 bytes
   */
  public static byte [] padTail(final byte [] a, final int length) {
<span class="nc" id="L1454">    byte [] padding = new byte[length];</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L1456">      padding[i] = 0;</span>
    }
<span class="nc" id="L1458">    return add(a,padding);</span>
  }

  /**
   * Split passed range.  Expensive operation relatively.  Uses BigInteger math.
   * Useful splitting ranges for MapReduce jobs.
   * @param a Beginning of range
   * @param b End of range
   * @param num Number of times to split range.  Pass 1 if you want to split
   * the range in two; i.e. one split.
   * @return Array of dividing values
   */
  public static byte [][] split(final byte [] a, final byte [] b, final int num) {
<span class="nc" id="L1471">    return split(a, b, false, num);</span>
  }

  /**
   * Split passed range.  Expensive operation relatively.  Uses BigInteger math.
   * Useful splitting ranges for MapReduce jobs.
   * @param a Beginning of range
   * @param b End of range
   * @param inclusive Whether the end of range is prefix-inclusive or is
   * considered an exclusive boundary.  Automatic splits are generally exclusive
   * and manual splits with an explicit range utilize an inclusive end of range.
   * @param num Number of times to split range.  Pass 1 if you want to split
   * the range in two; i.e. one split.
   * @return Array of dividing values
   */
  public static byte[][] split(final byte[] a, final byte[] b,
                               boolean inclusive, final int num) {
<span class="nc" id="L1488">    byte[][] ret = new byte[num + 2][];</span>
<span class="nc" id="L1489">    int i = 0;</span>
<span class="nc" id="L1490">    Iterable&lt;byte[]&gt; iter = iterateOnSplits(a, b, inclusive, num);</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">    if (iter == null)</span>
<span class="nc" id="L1492">      return null;</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">    for (byte[] elem : iter) {</span>
<span class="nc" id="L1494">      ret[i++] = elem;</span>
<span class="nc" id="L1495">    }</span>
<span class="nc" id="L1496">    return ret;</span>
  }

  /**
   * Iterate over keys within the passed range, splitting at an [a,b) boundary.
   */
  public static Iterable&lt;byte[]&gt; iterateOnSplits(final byte[] a,
                                                 final byte[] b, final int num)
  {
<span class="nc" id="L1505">    return iterateOnSplits(a, b, false, num);</span>
  }

  /**
   * Iterate over keys within the passed range.
   */
  public static Iterable&lt;byte[]&gt; iterateOnSplits(
      final byte[] a, final byte[]b, boolean inclusive, final int num)
  {
    byte [] aPadded;
    byte [] bPadded;
<span class="nc bnc" id="L1516" title="All 2 branches missed.">    if (a.length &lt; b.length) {</span>
<span class="nc" id="L1517">      aPadded = padTail(a, b.length - a.length);</span>
<span class="nc" id="L1518">      bPadded = b;</span>
<span class="nc bnc" id="L1519" title="All 2 branches missed.">    } else if (b.length &lt; a.length) {</span>
<span class="nc" id="L1520">      aPadded = a;</span>
<span class="nc" id="L1521">      bPadded = padTail(b, a.length - b.length);</span>
    } else {
<span class="nc" id="L1523">      aPadded = a;</span>
<span class="nc" id="L1524">      bPadded = b;</span>
    }
<span class="nc bnc" id="L1526" title="All 2 branches missed.">    if (compareTo(aPadded,bPadded) &gt;= 0) {</span>
<span class="nc" id="L1527">      throw new IllegalArgumentException(&quot;b &lt;= a&quot;);</span>
    }
<span class="nc bnc" id="L1529" title="All 2 branches missed.">    if (num &lt;= 0) {</span>
<span class="nc" id="L1530">      throw new IllegalArgumentException(&quot;num cannot be &lt;= 0&quot;);</span>
    }
<span class="nc" id="L1532">    byte [] prependHeader = {1, 0};</span>
<span class="nc" id="L1533">    final BigInteger startBI = new BigInteger(add(prependHeader, aPadded));</span>
<span class="nc" id="L1534">    final BigInteger stopBI = new BigInteger(add(prependHeader, bPadded));</span>
<span class="nc" id="L1535">    BigInteger diffBI = stopBI.subtract(startBI);</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">    if (inclusive) {</span>
<span class="nc" id="L1537">      diffBI = diffBI.add(BigInteger.ONE);</span>
    }
<span class="nc" id="L1539">    final BigInteger splitsBI = BigInteger.valueOf(num + 1);</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">    if(diffBI.compareTo(splitsBI) &lt; 0) {</span>
<span class="nc" id="L1541">      return null;</span>
    }
    final BigInteger intervalBI;
    try {
<span class="nc" id="L1545">      intervalBI = diffBI.divide(splitsBI);</span>
<span class="nc" id="L1546">    } catch(Exception e) {</span>
<span class="nc" id="L1547">      LOG.error(&quot;Exception caught during division&quot;, e);</span>
<span class="nc" id="L1548">      return null;</span>
<span class="nc" id="L1549">    }</span>

<span class="nc" id="L1551">    final Iterator&lt;byte[]&gt; iterator = new Iterator&lt;byte[]&gt;() {</span>
<span class="nc" id="L1552">      private int i = -1;</span>

      @Override
      public boolean hasNext() {
<span class="nc bnc" id="L1556" title="All 2 branches missed.">        return i &lt; num+1;</span>
      }

      @Override
      public byte[] next() {
<span class="nc" id="L1561">        i++;</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">        if (i == 0) return a;</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">        if (i == num + 1) return b;</span>

<span class="nc" id="L1565">        BigInteger curBI = startBI.add(intervalBI.multiply(BigInteger.valueOf(i)));</span>
<span class="nc" id="L1566">        byte [] padded = curBI.toByteArray();</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">        if (padded[1] == 0)</span>
<span class="nc" id="L1568">          padded = tail(padded, padded.length - 2);</span>
        else
<span class="nc" id="L1570">          padded = tail(padded, padded.length - 1);</span>
<span class="nc" id="L1571">        return padded;</span>
      }

      @Override
      public void remove() {
<span class="nc" id="L1576">        throw new UnsupportedOperationException();</span>
      }

    };

<span class="nc" id="L1581">    return new Iterable&lt;byte[]&gt;() {</span>
      @Override
      public Iterator&lt;byte[]&gt; iterator() {
<span class="nc" id="L1584">        return iterator;</span>
      }
    };
  }

  /**
   * @param bytes array to hash
   * @param offset offset to start from
   * @param length length to hash
   * */
  public static int hashCode(byte[] bytes, int offset, int length) {
<span class="nc" id="L1595">    int hash = 1;</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">    for (int i = offset; i &lt; offset + length; i++)</span>
<span class="nc" id="L1597">      hash = (31 * hash) + (int) bytes[i];</span>
<span class="nc" id="L1598">    return hash;</span>
  }

  /**
   * @param t operands
   * @return Array of byte arrays made from passed array of Text
   */
  public static byte [][] toByteArrays(final String [] t) {
<span class="nc" id="L1606">    byte [][] result = new byte[t.length][];</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">    for (int i = 0; i &lt; t.length; i++) {</span>
<span class="nc" id="L1608">      result[i] = Bytes.toBytes(t[i]);</span>
    }
<span class="nc" id="L1610">    return result;</span>
  }

  /**
   * @param column operand
   * @return A byte array of a byte array where first and only entry is
   * &lt;code&gt;column&lt;/code&gt;
   */
  public static byte [][] toByteArrays(final String column) {
<span class="nc" id="L1619">    return toByteArrays(toBytes(column));</span>
  }

  /**
   * @param column operand
   * @return A byte array of a byte array where first and only entry is
   * &lt;code&gt;column&lt;/code&gt;
   */
  public static byte [][] toByteArrays(final byte [] column) {
<span class="nc" id="L1628">    byte [][] result = new byte[1][];</span>
<span class="nc" id="L1629">    result[0] = column;</span>
<span class="nc" id="L1630">    return result;</span>
  }

  /**
   * Binary search for keys in indexes.
   *
   * @param arr array of byte arrays to search for
   * @param key the key you want to find
   * @param offset the offset in the key you want to find
   * @param length the length of the key
   * @param comparator a comparator to compare.
   * @return zero-based index of the key, if the key is present in the array.
   *         Otherwise, a value -(i + 1) such that the key is between arr[i -
   *         1] and arr[i] non-inclusively, where i is in [0, i], if we define
   *         arr[-1] = -Inf and arr[N] = Inf for an N-element array. The above
   *         means that this function can return 2N + 1 different values
   *         ranging from -(N + 1) to N - 1.
   */
  public static int binarySearch(byte [][]arr, byte []key, int offset,
                                 int length, RawComparator&lt;?&gt; comparator) {
<span class="nc" id="L1650">    int low = 0;</span>
<span class="nc" id="L1651">    int high = arr.length - 1;</span>

<span class="nc bnc" id="L1653" title="All 2 branches missed.">    while (low &lt;= high) {</span>
<span class="nc" id="L1654">      int mid = (low+high) &gt;&gt;&gt; 1;</span>
      // we have to compare in this order, because the comparator order
      // has special logic when the 'left side' is a special key.
<span class="nc" id="L1657">      int cmp = comparator.compare(key, offset, length,</span>
          arr[mid], 0, arr[mid].length);
      // key lives above the midpoint
<span class="nc bnc" id="L1660" title="All 2 branches missed.">      if (cmp &gt; 0)</span>
<span class="nc" id="L1661">        low = mid + 1;</span>
        // key lives below the midpoint
<span class="nc bnc" id="L1663" title="All 2 branches missed.">      else if (cmp &lt; 0)</span>
<span class="nc" id="L1664">        high = mid - 1;</span>
        // BAM. how often does this really happen?
      else
<span class="nc" id="L1667">        return mid;</span>
<span class="nc" id="L1668">    }</span>
<span class="nc" id="L1669">    return - (low+1);</span>
  }

  /**
   * Bytewise binary increment/deincrement of long contained in byte array
   * on given amount.
   *
   * @param value - array of bytes containing long (length &lt;= SIZEOF_LONG)
   * @param amount value will be incremented on (deincremented if negative)
   * @return array of bytes containing incremented long (length == SIZEOF_LONG)
   */
  public static byte [] incrementBytes(byte[] value, long amount)
  {
<span class="nc" id="L1682">    byte[] val = value;</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">    if (val.length &lt; SIZEOF_LONG) {</span>
      // Hopefully this doesn't happen too often.
      byte [] newvalue;
<span class="nc bnc" id="L1686" title="All 2 branches missed.">      if (val[0] &lt; 0) {</span>
<span class="nc" id="L1687">        newvalue = new byte[]{-1, -1, -1, -1, -1, -1, -1, -1};</span>
      } else {
<span class="nc" id="L1689">        newvalue = new byte[SIZEOF_LONG];</span>
      }
<span class="nc" id="L1691">      System.arraycopy(val, 0, newvalue, newvalue.length - val.length,</span>
          val.length);
<span class="nc" id="L1693">      val = newvalue;</span>
<span class="nc bnc" id="L1694" title="All 2 branches missed.">    } else if (val.length &gt; SIZEOF_LONG) {</span>
<span class="nc" id="L1695">      throw new IllegalArgumentException(&quot;Increment Bytes - value too big: &quot; +</span>
          val.length);
    }
<span class="nc bnc" id="L1698" title="All 2 branches missed.">    if(amount == 0) return val;</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">    if(val[0] &lt; 0){</span>
<span class="nc" id="L1700">      return binaryIncrementNeg(val, amount);</span>
    }
<span class="nc" id="L1702">    return binaryIncrementPos(val, amount);</span>
  }

  /* increment/deincrement for positive value */
  private static byte [] binaryIncrementPos(byte [] value, long amount) {
<span class="nc" id="L1707">    long amo = amount;</span>
<span class="nc" id="L1708">    int sign = 1;</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">    if (amount &lt; 0) {</span>
<span class="nc" id="L1710">      amo = -amount;</span>
<span class="nc" id="L1711">      sign = -1;</span>
    }
<span class="nc bnc" id="L1713" title="All 2 branches missed.">    for(int i=0;i&lt;value.length;i++) {</span>
<span class="nc" id="L1714">      int cur = ((int)amo % 256) * sign;</span>
<span class="nc" id="L1715">      amo = (amo &gt;&gt; 8);</span>
<span class="nc" id="L1716">      int val = value[value.length-i-1] &amp; 0x0ff;</span>
<span class="nc" id="L1717">      int total = val + cur;</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">      if(total &gt; 255) {</span>
<span class="nc" id="L1719">        amo += sign;</span>
<span class="nc" id="L1720">        total %= 256;</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">      } else if (total &lt; 0) {</span>
<span class="nc" id="L1722">        amo -= sign;</span>
      }
<span class="nc" id="L1724">      value[value.length-i-1] = (byte)total;</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">      if (amo == 0) return value;</span>
    }
<span class="nc" id="L1727">    return value;</span>
  }

  /* increment/deincrement for negative value */
  private static byte [] binaryIncrementNeg(byte [] value, long amount) {
<span class="nc" id="L1732">    long amo = amount;</span>
<span class="nc" id="L1733">    int sign = 1;</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">    if (amount &lt; 0) {</span>
<span class="nc" id="L1735">      amo = -amount;</span>
<span class="nc" id="L1736">      sign = -1;</span>
    }
<span class="nc bnc" id="L1738" title="All 2 branches missed.">    for(int i=0;i&lt;value.length;i++) {</span>
<span class="nc" id="L1739">      int cur = ((int)amo % 256) * sign;</span>
<span class="nc" id="L1740">      amo = (amo &gt;&gt; 8);</span>
<span class="nc" id="L1741">      int val = ((~value[value.length-i-1]) &amp; 0x0ff) + 1;</span>
<span class="nc" id="L1742">      int total = cur - val;</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">      if(total &gt;= 0) {</span>
<span class="nc" id="L1744">        amo += sign;</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">      } else if (total &lt; -256) {</span>
<span class="nc" id="L1746">        amo -= sign;</span>
<span class="nc" id="L1747">        total %= 256;</span>
      }
<span class="nc" id="L1749">      value[value.length-i-1] = (byte)total;</span>
<span class="nc bnc" id="L1750" title="All 2 branches missed.">      if (amo == 0) return value;</span>
    }
<span class="nc" id="L1752">    return value;</span>
  }

  /**
   * Writes a string as a fixed-size field, padded with zeros.
   */
  public static void writeStringFixedSize(final DataOutput out, String s,
                                          int size) throws IOException {
<span class="nc" id="L1760">    byte[] b = toBytes(s);</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">    if (b.length &gt; size) {</span>
<span class="nc" id="L1762">      throw new IOException(&quot;Trying to write &quot; + b.length + &quot; bytes (&quot; +</span>
<span class="nc" id="L1763">          toStringBinary(b) + &quot;) into a field of length &quot; + size);</span>
    }

<span class="nc" id="L1766">    out.writeBytes(s);</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">    for (int i = 0; i &lt; size - s.length(); ++i)</span>
<span class="nc" id="L1768">      out.writeByte(0);</span>
<span class="nc" id="L1769">  }</span>

  /**
   * Reads a fixed-size field and interprets it as a string padded with zeros.
   */
  public static String readStringFixedSize(final DataInput in, int size)
      throws IOException {
<span class="nc" id="L1776">    byte[] b = new byte[size];</span>
<span class="nc" id="L1777">    in.readFully(b);</span>
<span class="nc" id="L1778">    int n = b.length;</span>
<span class="nc bnc" id="L1779" title="All 4 branches missed.">    while (n &gt; 0 &amp;&amp; b[n - 1] == 0)</span>
<span class="nc" id="L1780">      --n;</span>

<span class="nc" id="L1782">    return toString(b, 0, n);</span>
  }

  /**
   * Copy the byte array given in parameter and return an instance
   * of a new byte array with the same length and the same content.
   * @param bytes the byte array to duplicate
   * @return a copy of the given byte array
   */
  public static byte [] copy(byte [] bytes) {
<span class="nc bnc" id="L1792" title="All 2 branches missed.">    if (bytes == null) return null;</span>
<span class="nc" id="L1793">    byte [] result = new byte[bytes.length];</span>
<span class="nc" id="L1794">    System.arraycopy(bytes, 0, result, 0, bytes.length);</span>
<span class="nc" id="L1795">    return result;</span>
  }

  /**
   * Copy the byte array given in parameter and return an instance
   * of a new byte array with the same length and the same content.
   * @param bytes the byte array to copy from
   * @return a copy of the given designated byte array
   * @param offset
   * @param length
   */
  public static byte [] copy(byte [] bytes, final int offset, final int length) {
<span class="nc bnc" id="L1807" title="All 2 branches missed.">    if (bytes == null) return null;</span>
<span class="nc" id="L1808">    byte [] result = new byte[length];</span>
<span class="nc" id="L1809">    System.arraycopy(bytes, offset, result, 0, length);</span>
<span class="nc" id="L1810">    return result;</span>
  }

  /**
   * Search sorted array &quot;a&quot; for byte &quot;key&quot;. I can't remember if I wrote this or copied it from
   * somewhere. (mcorgan)
   * @param a Array to search. Entries must be sorted and unique.
   * @param fromIndex First index inclusive of &quot;a&quot; to include in the search.
   * @param toIndex Last index exclusive of &quot;a&quot; to include in the search.
   * @param key The byte to search for.
   * @return The index of key if found. If not found, return -(index + 1), where negative indicates
   *         &quot;not found&quot; and the &quot;index + 1&quot; handles the &quot;-0&quot; case.
   */
  public static int unsignedBinarySearch(byte[] a, int fromIndex, int toIndex, byte key) {
<span class="nc" id="L1824">    int unsignedKey = key &amp; 0xff;</span>
<span class="nc" id="L1825">    int low = fromIndex;</span>
<span class="nc" id="L1826">    int high = toIndex - 1;</span>

<span class="nc bnc" id="L1828" title="All 2 branches missed.">    while (low &lt;= high) {</span>
<span class="nc" id="L1829">      int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L1830">      int midVal = a[mid] &amp; 0xff;</span>

<span class="nc bnc" id="L1832" title="All 2 branches missed.">      if (midVal &lt; unsignedKey) {</span>
<span class="nc" id="L1833">        low = mid + 1;</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">      } else if (midVal &gt; unsignedKey) {</span>
<span class="nc" id="L1835">        high = mid - 1;</span>
      } else {
<span class="nc" id="L1837">        return mid; // key found</span>
      }
<span class="nc" id="L1839">    }</span>
<span class="nc" id="L1840">    return -(low + 1); // key not found.</span>
  }

  /**
   * Treat the byte[] as an unsigned series of bytes, most significant bits first.  Start by adding
   * 1 to the rightmost bit/byte and carry over all overflows to the more significant bits/bytes.
   *
   * @param input The byte[] to increment.
   * @return The incremented copy of &quot;in&quot;.  May be same length or 1 byte longer.
   */
  public static byte[] unsignedCopyAndIncrement(final byte[] input) {
<span class="nc" id="L1851">    byte[] copy = copy(input);</span>
<span class="nc bnc" id="L1852" title="All 2 branches missed.">    if (copy == null) {</span>
<span class="nc" id="L1853">      throw new IllegalArgumentException(&quot;cannot increment null array&quot;);</span>
    }
<span class="nc bnc" id="L1855" title="All 2 branches missed.">    for (int i = copy.length - 1; i &gt;= 0; --i) {</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">      if (copy[i] == -1) {// -1 is all 1-bits, which is the unsigned maximum</span>
<span class="nc" id="L1857">        copy[i] = 0;</span>
      } else {
<span class="nc" id="L1859">        ++copy[i];</span>
<span class="nc" id="L1860">        return copy;</span>
      }
    }
    // we maxed out the array
<span class="nc" id="L1864">    byte[] out = new byte[copy.length + 1];</span>
<span class="nc" id="L1865">    out[0] = 1;</span>
<span class="nc" id="L1866">    System.arraycopy(copy, 0, out, 1, copy.length);</span>
<span class="nc" id="L1867">    return out;</span>
  }

  public static boolean equals(List&lt;byte[]&gt; a, List&lt;byte[]&gt; b) {
<span class="nc bnc" id="L1871" title="All 2 branches missed.">    if (a == null) {</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">      if (b == null) {</span>
<span class="nc" id="L1873">        return true;</span>
      }
<span class="nc" id="L1875">      return false;</span>
    }
<span class="nc bnc" id="L1877" title="All 2 branches missed.">    if (b == null) {</span>
<span class="nc" id="L1878">      return false;</span>
    }
<span class="nc bnc" id="L1880" title="All 2 branches missed.">    if (a.size() != b.size()) {</span>
<span class="nc" id="L1881">      return false;</span>
    }
<span class="nc bnc" id="L1883" title="All 2 branches missed.">    for (int i = 0; i &lt; a.size(); ++i) {</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">      if (!Bytes.equals(a.get(i), b.get(i))) {</span>
<span class="nc" id="L1885">        return false;</span>
      }
    }
<span class="nc" id="L1888">    return true;</span>
  }

  /**
   * Returns the index of the first appearance of the value {@code target} in
   * {@code array}.
   *
   * @param array an array of {@code byte} values, possibly empty
   * @param target a primitive {@code byte} value
   * @return the least index {@code i} for which {@code array[i] == target}, or
   *     {@code -1} if no such index exists.
   */
  public static int indexOf(byte[] array, byte target) {
<span class="nc bnc" id="L1901" title="All 2 branches missed.">    for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">      if (array[i] == target) {</span>
<span class="nc" id="L1903">        return i;</span>
      }
    }
<span class="nc" id="L1906">    return -1;</span>
  }

  /**
   * Returns the start position of the first occurrence of the specified {@code
   * target} within {@code array}, or {@code -1} if there is no such occurrence.
   *
   * &lt;p&gt;More formally, returns the lowest index {@code i} such that {@code
   * java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
   * the same elements as {@code target}.
   *
   * @param array the array to search for the sequence {@code target}
   * @param target the array to search for as a sub-sequence of {@code array}
   */
  public static int indexOf(byte[] array, byte[] target) {
<span class="nc" id="L1921">    checkNotNull(array, &quot;array&quot;);</span>
<span class="nc" id="L1922">    checkNotNull(target, &quot;target&quot;);</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">    if (target.length == 0) {</span>
<span class="nc" id="L1924">      return 0;</span>
    }

    outer:
<span class="nc bnc" id="L1928" title="All 2 branches missed.">    for (int i = 0; i &lt; array.length - target.length + 1; i++) {</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">      for (int j = 0; j &lt; target.length; j++) {</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">        if (array[i + j] != target[j]) {</span>
<span class="nc" id="L1931">          continue outer;</span>
        }
      }
<span class="nc" id="L1934">      return i;</span>
    }
<span class="nc" id="L1936">    return -1;</span>
  }

  /**
   * @param array an array of {@code byte} values, possibly empty
   * @param target a primitive {@code byte} value
   * @return {@code true} if {@code target} is present as an element anywhere in {@code array}.
   */
  public static boolean contains(byte[] array, byte target) {
<span class="nc bnc" id="L1945" title="All 2 branches missed.">    return indexOf(array, target) &gt; -1;</span>
  }

  /**
   * @param array an array of {@code byte} values, possibly empty
   * @param target an array of {@code byte}
   * @return {@code true} if {@code target} is present anywhere in {@code array}
   */
  public static boolean contains(byte[] array, byte[] target) {
<span class="nc bnc" id="L1954" title="All 2 branches missed.">    return indexOf(array, target) &gt; -1;</span>
  }

  /**
   * Fill given array with zeros.
   * @param b array which needs to be filled with zeros
   */
  public static void zero(byte[] b) {
<span class="nc" id="L1962">    zero(b, 0, b.length);</span>
<span class="nc" id="L1963">  }</span>

  /**
   * Fill given array with zeros at the specified position.
   * @param b
   * @param offset
   * @param length
   */
  public static void zero(byte[] b, int offset, int length) {
<span class="nc" id="L1972">    checkPositionIndex(offset, b.length, &quot;offset&quot;);</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">    checkArgument(length &gt; 0, &quot;length must be greater than 0&quot;);</span>
<span class="nc" id="L1974">    checkPositionIndex(offset + length, b.length, &quot;offset + length&quot;);</span>
<span class="nc" id="L1975">    Arrays.fill(b, offset, offset + length, (byte) 0);</span>
<span class="nc" id="L1976">  }</span>

<span class="nc" id="L1978">  private static final SecureRandom RNG = new SecureRandom();</span>

  /**
   * Fill given array with random bytes.
   * @param b array which needs to be filled with random bytes
   */
  public static void random(byte[] b) {
<span class="nc" id="L1985">    RNG.nextBytes(b);</span>
<span class="nc" id="L1986">  }</span>

  /**
   * Fill given array with random bytes at the specified position.
   * @param b
   * @param offset
   * @param length
   */
  public static void random(byte[] b, int offset, int length) {
<span class="nc" id="L1995">    checkPositionIndex(offset, b.length, &quot;offset&quot;);</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">    checkArgument(length &gt; 0, &quot;length must be greater than 0&quot;);</span>
<span class="nc" id="L1997">    checkPositionIndex(offset + length, b.length, &quot;offset + length&quot;);</span>
<span class="nc" id="L1998">    byte[] buf = new byte[length];</span>
<span class="nc" id="L1999">    RNG.nextBytes(buf);</span>
<span class="nc" id="L2000">    System.arraycopy(buf, 0, b, offset, length);</span>
<span class="nc" id="L2001">  }</span>

  /**
   * Create a max byte array with the specified max byte count
   * @param maxByteCount the length of returned byte array
   * @return the created max byte array
   */
  public static byte[] createMaxByteArray(int maxByteCount) {
<span class="nc" id="L2009">    byte[] maxByteArray = new byte[maxByteCount];</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">    for (int i = 0; i &lt; maxByteArray.length; i++) {</span>
<span class="nc" id="L2011">      maxByteArray[i] = (byte) 0xff;</span>
    }
<span class="nc" id="L2013">    return maxByteArray;</span>
  }

  /**
   * Create a byte array which is multiple given bytes
   * @param srcBytes
   * @param multiNum
   * @return byte array
   */
  public static byte[] multiple(byte[] srcBytes, int multiNum) {
<span class="nc bnc" id="L2023" title="All 2 branches missed.">    if (multiNum &lt;= 0) {</span>
<span class="nc" id="L2024">      return new byte[0];</span>
    }
<span class="nc" id="L2026">    byte[] result = new byte[srcBytes.length * multiNum];</span>
<span class="nc bnc" id="L2027" title="All 2 branches missed.">    for (int i = 0; i &lt; multiNum; i++) {</span>
<span class="nc" id="L2028">      System.arraycopy(srcBytes, 0, result, i * srcBytes.length,</span>
          srcBytes.length);
    }
<span class="nc" id="L2031">    return result;</span>
  }

  /**
   * Convert a byte array into a hex string
   * @param b
   */
  public static String toHex(byte[] b) {
<span class="nc bnc" id="L2039" title="All 2 branches missed.">    checkArgument(b.length &gt; 0, &quot;length must be greater than 0&quot;);</span>
<span class="nc" id="L2040">    return String.format(&quot;%x&quot;, new BigInteger(1, b));</span>
  }

  /**
   * Create a byte array from a string of hash digits. The length of the
   * string must be a multiple of 2
   * @param hex
   */
  public static byte[] fromHex(String hex) {
<span class="nc bnc" id="L2049" title="All 2 branches missed.">    checkArgument(hex.length() &gt; 0, &quot;length must be greater than 0&quot;);</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">    checkArgument(hex.length() % 2 == 0, &quot;length must be a multiple of 2&quot;);</span>
    // Make sure letters are upper case
<span class="nc" id="L2052">    hex = hex.toUpperCase();</span>
<span class="nc" id="L2053">    byte[] b = new byte[hex.length() / 2];</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">    for (int i = 0; i &lt; b.length; i++) {</span>
<span class="nc" id="L2055">      b[i] = (byte)((toBinaryFromHex((byte)hex.charAt(2 * i)) &lt;&lt; 4) +</span>
<span class="nc" id="L2056">          toBinaryFromHex((byte)hex.charAt((2 * i + 1))));</span>
    }
<span class="nc" id="L2058">    return b;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>